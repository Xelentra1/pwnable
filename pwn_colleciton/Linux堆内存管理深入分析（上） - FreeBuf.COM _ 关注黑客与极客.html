<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
                              _.._        ,------------.
                           ,'      `.    ( We want you! )
                          /  __) __` \    `-,----------'
                         (  (`-`(-')  ) _.-'
                         /)  \  = /  (
                        /'    |--' .  \
                       (  ,---|  `-.)__`
                        )(  `-.,--'   _`-.
                       '/,'          (  Uu",
                        (_       ,    `/,-' )
                        `.__,  : `-'/  /`--'
                          |     `--'  |
                          `   `-._   /
                           \        (
                           /\ .      \.  freebuf
                          / |` \     ,-\
                         /  \| .)   /   \
                        ( ,'|\    ,'     :
                        | \,`.`--"/      }
                        `,'    \  |,'    /
                       / "-._   `-/      |
                       "-.   "-.,'|     ;
                      /        _/["---'""]
                     :        /  |"-     '
                     '           |      /
                                 `      |
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Linux堆内存管理深入分析（上） - FreeBuf.COM | 关注黑客与极客</title>
<meta name="description" content="作者：走位@阿里聚安全​


0&nbsp;前言
近年来，漏洞挖掘越来越火，各种漏洞挖掘、利用的分析文章层出不穷。从大方向来看，主要有基于栈溢出的漏洞利用和基于堆溢出的漏洞利用两种。国内关于栈溢出的资料相对较多，…" />
<meta name="keywords" content="linux, 堆内存" />
<meta name="baidu-site-verification" content="nKKKqQxp6R" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="renderer" content="webkit">
<meta property="qc:admins" content="6620477777662552566375" />
<link rel='stylesheet' id='wpfp-css' href='http://www.freebuf.com/buf/plugins/wp-favorite-posts/wpfp.css' type='text/css' />
<link rel='stylesheet' id='wp-recentcomments-css'  href='http://static.3001.net/css/recentcomments/wp-recentcomments.css?ver=2.2.3' type='text/css' media='screen' />
<link rel='stylesheet' id='mycred-widget-css'  href='http://www.freebuf.com/buf/plugins/gold/assets/css/widget.css?ver=1.3.2.1' type='text/css' media='all' />
<script type='text/javascript' src='http://static.3001.net/js/header/jquery.min.js?ver=3.6.1'></script>
<script type='text/javascript' src='http://www.freebuf.com/buf/plugins/wp-favorite-posts/wpfp.js?ver=3.6.1'></script>
<link rel='prev' title='内网渗透防御：如何防御Hash注入攻击' href='http://www.freebuf.com/articles/terminal/104063.html' />
<link rel='next' title='走近Docker安全扫描器' href='http://www.freebuf.com/sectool/104080.html' />
<link rel='canonical' href='http://www.freebuf.com/articles/system/104144.html' />
<link rel='shortlink' href='http://www.freebuf.com/?p=104144' />

<link rel="stylesheet" href="http://static.3001.net/css/highslide/highslide.css" type="text/css" />
<script type="text/javascript" src="http://static.3001.net/js/highslide/highslide-with-html.packed.js"></script>
<script type="text/javascript">
jQuery(document).ready(function($) {
    hs.graphicsDir = "http://www.freebuf.com/buf/plugins/auto-highslide/images/graphics/";
    hs.outlineType = "rounded-white";
    hs.dimmingOpacity = 0.8;
    hs.outlineWhileAnimating = true;
    hs.showCredits = false;
    hs.captionEval = "this.thumb.alt";
    hs.numberPosition = "caption";
    hs.align = "center";
    hs.transitions = ["expand", "crossfade"];
    hs.addSlideshow({
        interval: 5000,
        repeat: true,
        useControls: true,
        fixedControls: "fit",
        overlayOptions: {
            opacity: 0.75,
            position: "bottom center",
            hideOnMouseOut: true

        }

    });
});
</script>
          <script language="JavaScript" type="text/javascript" src="http://www.freebuf.com/buf/plugins/cartpauj-pm/js/script.js"></script>
      <link rel="stylesheet" type="text/css" href="http://www.freebuf.com/buf/plugins/cartpauj-pm/style/style.css" />
      <script type="text/javascript" src="http://www.freebuf.com/buf/plugins/simditor/highlight/highlight.pack.js"></script><link type="text/css" rel="stylesheet" href=" http://www.freebuf.com/buf/plugins/simditor/highlight/styles/default.css" />	<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
<link rel="shortcut icon" href="http://static.freebuf.com/images/favicon.ico" />
<link href="http://static.3001.net/css/new/bootstrap.min.css?ver=2016051701" rel="stylesheet" media="screen">
<link href="http://static.3001.net/css/new/style.css?ver=2016071401" rel="stylesheet" type="text/css">
<style type="text/css">
#contenttxt hr {
  display: block;
  height: 0px;
  border: 0;
  border-top: 1px solid #ccc;
  margin: 15px 0;
  padding: 0;
}
#contenttxt table {
  width: 100%;
  table-layout: fixed;
  border-collapse: collapse;
  border-spacing: 0;
  margin: 15px 0;
}
#contenttxt table thead {
  background-color: #f9f9f9;
}
#contenttxt table td, #contenttxt table th {
  min-width: 40px;
  height: 30px;
  border: 1px solid #ccc;
  vertical-align: top;
  padding: 2px 4px;
  text-align: left;
  box-sizing: border-box;
  white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;
}
#contenttxt table td.active, #contenttxt table th.active {
  background-color: #ffffee;
  white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;
}
</style>
<script src="http://www.freebuf.com/buf/themes/freebuf/js/jquery-2.0.3.min.js"></script>
<script src="http://www.freebuf.com/buf/themes/freebuf/js/bootstrap.min.js"></script>
<script src="http://www.freebuf.com/buf/themes/freebuf/js/slider.js?2016022501.1" type="text/javascript"></script>
<script src="http://www.freebuf.com/buf/themes/freebuf/js/jquery.sticky.js" type="text/javascript"></script>
<script src="http://static.3001.net/js/focus/bjqs-1.3.min.js" type="text/javascript" ></script>
<script src="http://www.freebuf.com/buf/themes/freebuf/js/mosaic.1.0.1.min.js" type="text/javascript" ></script>
<!--[if lt IE 9]>
    <script src="http://www.freebuf.com/buf/themes/freebuf/js/html5shiv.min.js"></script>
    <script src="http://www.freebuf.com/buf/themes/freebuf/js/respond.min.js"></script>
<![endif]-->
</head>

<body>
<!----------header---------->
<div class="main-header">
  <nav class="navbar navbar-inverse" role="navigation">

    <div class="container">
      <div class="navbar-header">
        <button class="navbar-toggle collapsed" aria-controls="navbar" aria-expanded="false" data-target="#navbar" data-toggle="collapse" type="button"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button>
        <div class="logo"><a href="http://www.freebuf.com"><img src="http://image.3001.net/images/new/logo.png"/></a><span class="visible-lg-block">关注黑客与极客</span></div>
      </div>
      <div id="navbar" class="navbar-collapse collapse globalnav" aria-expanded="false" >
        <ul class="nav nav-pills pull-left">
          <li ><a href="http://www.freebuf.com">首页</a></li>
          <li class="dropdown"> <a href="javascript:viod(0);" class="dropdown-toggle" data-toggle="dropdown">分类阅读<b class="caret"></b> </a>
            <ul class="dropdown-menu article-nav">
              <li> <strong>黑客</strong>
                <div class="nav"> <a href="http://www.freebuf.com/vuls" target="_blank">漏洞</a> <a href="http://www.freebuf.com/sectool" target="_blank">安全工具</a> <a href="http://www.freebuf.com/articles/web" target="_blank">WEB安全</a> <a href="http://www.freebuf.com/articles/system" target="_blank">系统安全</a> <a href="http://www.freebuf.com/articles/network" target="_blank">网络安全</a> <a href="http://www.freebuf.com/articles/wireless" target="_blank">无线安全</a> <a href="http://www.freebuf.com/articles/terminal" target="_blank">设备/客户端安全</a> <a href="http://www.freebuf.com/articles/database" target="_blank">数据库安全</a> <a href="http://www.freebuf.com/articles/security-management" target="_blank">安全管理</a></div>
              </li>
              <li> <strong>极客</strong>
                <div class="nav"> <a href="http://www.freebuf.com/geek" target="_blank">极客有意思</a> <a href="http://www.freebuf.com/news/others" target="_blank">周边</a></div>
              </li>
              <li> <strong>特色</strong>
                <div class="nav"><a href="http://www.freebuf.com/news/special" target="_blank">头条</a><a href="http://www.freebuf.com/articles/people" target="_blank">人物志</a><a href="http://www.freebuf.com/fevents" target="_blank">活动</a><a href="http://www.freebuf.com/video" target="_blank">视频</a><a href="http://www.freebuf.com/articles/neopoints" target="_blank">观点</a><a href="http://www.freebuf.com/jobs" target="_blank">招聘</a><a href="http://www.freebuf.com/paper/" target="_blank">报告</a></div>
              </li>
            </ul>
          </li>
          <li > <a href="http://www.freebuf.com/wenku" target="_blank">文库<b class="icon-betr"></b> </a></li>
          <li><a href="http://bar.freebuf.com/" target="_blank">小酒馆</a><span ></span></li>
          <li><a href="http://open.freebuf.com" target="_blank">公开课</a></li>
          <li><a href="http://shop.freebuf.com" target="_blank">商城</a></li>
          <li><a href="https://www.vulbox.com" target="_blank">漏洞盒子</a><span class="icon-hot"></span></li>
        </ul>
                <div class="main-login">
          <ul class="nav nav-pills pull-right login">
            <li class="pull-right"><a href="https://account.tophant.com/register.html">注册</a></li>
            <li class="active pull-right"><a href="http://www.freebuf.com/oauth">登录</a></li>
          </ul>
        </div>
              </div>
    </div>
  </nav>
</div>
<script type="text/javascript">
function ntabs(thisObj,Num){
    if(thisObj.className == "active")return;
    var tabObj = thisObj.parentNode.id;
    var tabList = document.getElementById(tabObj).getElementsByTagName("li");
    for(i=0; i <tabList.length; i++)
    {
        if (i == Num){
            thisObj.className = "active"; 
            document.getElementById(tabObj+"_content"+i).style.display = "block";
        }else{
            tabList[i].className = "normal"; 
            document.getElementById(tabObj+"_content"+i).style.display = "none";
        }
    } 
}
</script> 
<!----------header end----------><script>
    jQuery(window).load(function(){
      if(jQuery(window).width()>480){
        jQuery(".main-header").sticky({ topSpacing: 0 });
      }else{
        jQuery(".main-header nav").removeClass("navbar-fixed-top");
      }
      jQuery("#mar-right").sticky({ topSpacing: 105,bottomSpacing: 410 });
    });
</script>
<script type="text/javascript" src="http://static.3001.net/js/pretty/prettify.js"></script>
<script type="text/javascript" src="http://static.3001.net/js/header/lazyload.js"></script>
<script type="text/javascript" charset="utf-8">
      jQuery(function() {
          jQuery("img").lazyload({
              effect : "fadeIn"
          });
      });
 </script>
<script type="text/javascript">
    window.onload = function(){
        prettyPrint();
    }
</script>
<script language="JavaScript" type="text/javascript">
//<![CDATA[
var va = "您已经点亮过了";
function acv_vote(id,option, m){
  if( m==null) m =''; m = m + '';
  jQuery('#acv_stat_'+m+id).html('Loading...');
  var url="http://www.freebuf.com/index.php?acv_ajax=true&option="+option+"&ID="+id;
  jQuery.get(url,function(d){
    d =d.split('|');var s='#acv_stat_'+m+d[0];
    var sele = '#cos_support-'+m+id,unsele = '#cos_unsupport-'+m+id,tpjs = 'javascript:alert(va)';
    jQuery( s ).html( d[1] );jQuery(s).fadeOut(400,function(){jQuery(s).fadeIn();});
    if( d[2] == 1 ){ jQuery(sele).html(jQuery(sele).html()*1+1); }
    if( d[2] == -1 ){ jQuery(unsele).html(jQuery(unsele).html()*1+1); }
    jQuery('#vote4-'+id).attr('href',tpjs);jQuery('#vote4-2'+id).attr('href',tpjs);
    jQuery('#votea-'+id).attr('href',tpjs);jQuery('#votea-2'+id).attr('href',tpjs);
  });
}
  
$(document).on("mouseenter",".comment-tools",function(){
  $(this).find(".btn-report").show();
  $(this).find(".btn-report").addClass("hover");
}).on("mouseleave",".comment-tools",function(){
  var $_this = $(this);
  $(this).find(".btn-report").removeClass("hover");
  if(!$(this).find(".dropup").hasClass('open')){
    $(this).find(".btn-report").hide(); 
    $_this.find(".dropdown-menu").css("display","none");
  }else{
    setTimeout(function(){
      if(!$_this.find(".btn-report").hasClass("hover")){
        $_this.find(".dropup").removeClass("open");
        $_this.find(".dropdown-menu").css("display","none");
        $_this.find(".btn-report").hide(); 
      }
    },"500");
  }
})

$(document).on("click",".click_report",function(){
  $(this).parent().parent().css("display","none");
  var id = $(this).attr("data-id");
  var url="http://www.freebuf.com/index.php?acv_ajax=true&option=0&ID="+id;
  $_this = $(this);
  jQuery.get(url,function(d){
    d =d.split('|');
    if(d[1]=='您已经点过灯了'){
      d[1] = '您已经举报过了';
    }
    if(d[1]=='Thank you'){
      d[1] = '举报成功';
    }
    $_this.parent().parent().parent().find(".btn-report").text(d[1]);
    $_this.parent().parent().parent().find(".btn-report").css("display","block");
  })
})

$(document).on("click",".btn-report",function(){
  if($(this).parent().hasClass('open')){
    $(this).parent().find(".dropdown-menu").css("display","block");
  }else{
    $(this).parent().find(".dropdown-menu").css("display","none");
  }
})
//]]>
</script>
<div class="container pad-top35">
  <div class="row clearfix">
        <div class="col-md-9">
      <div class="article-wrap panel panel-default">
                    <div class="articlecontent">
        <div class="title">
          <h2> Linux堆内存管理深入分析（上） </h2>
          <div class="property">
		  		  <span class="name"><a href="http://www.freebuf.com/author/%E9%98%BF%E9%87%8C%E8%81%9A%E5%AE%89%E5%85%A8" title="由 阿里聚安全 发布" rel="author">阿里聚安全</a></span>
		  		  <span class="icon-f"><a href="http://www.freebuf.com/bufer" target="_blank"><img src="http://image.3001.net/images/index/f2.png" title="认证厂商"></a></span>
		  <span class="time">2016-05-13</span>
             
		  <span class="look">共<strong>117654</strong>人围观
              ，发现 <strong>4</strong> 个不明物体 </span>          </span>
		  <span class="tags">		  
		  <a href="http://www.freebuf.com/./articles/system">系统安全</a></span>	
        <span class="tags_01"></span>			  
		  </div>
        </div>
                        <div id="contenttxt">
           <h3><span style="font-size: 16px;"><strong>作者：走位@阿里聚安全</strong></span><span style="font-size: 16px;"><strong>​</strong></span></h3>
<p style="text-align: center;"><img data-original="http://image.3001.net/images/20160512/1463052641957.png!small" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="1-16021GQ311103.png" height="431" width="690"></p>
<noscript><img src="http://image.3001.net/images/20160512/1463052641957.png!small" alt="1-16021GQ311103.png" height="431" width="690"></p></noscript>
<h2><span style="font-size: 18px;"><strong>0&nbsp;</strong></span><span style="font-size: 18px;"><strong>前言</strong></span></h2>
<p><span style="color: rgb(0, 176, 80);"><b><span style="font-size: 14px;">近年来，漏洞挖掘越来越火，各种漏洞挖掘、利用的分析文章层出不穷。从大方向来看，主要有基于栈溢出的漏洞利用和基于堆溢出的漏洞利用两种。国内关于栈溢出的资料相对较多，这里就不累述了，但是关于堆溢出的漏洞利用资料就很少了。</span></b></span></p>
<p><span style="font-size: 14px;">鄙人以为主要是堆溢出漏洞的门槛较高，需要先吃透相应操作系统的堆内存管理机制，而这部分内容一直是一个难点。<b>因此本系列文章主要从</b></span><b><span style="font-size: 14px;">Linux</span><span style="font-size: 14px;">系统堆内存管理机制出发，逐步介绍诸如基本堆溢出漏洞、基于</span><span style="font-size: 14px;">unlink</span><span style="font-size: 14px;">的堆溢出漏洞利用、</span><span style="font-size: 14px;">double free</span><span style="font-size: 14px;">、</span><span style="font-size: 14px;">use-after-free</span><span style="font-size: 14px;">等等常见的堆溢出漏洞利用技术。</span></b></p>
<p><span style="font-size: 14px;">前段时间偶然学习了这篇文章：<a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank">Understanding glibc malloc</a></span></p>
<p><span style="font-size: 14px;">该文是我近段时间以来读到的最好文章之一，文章浅显易懂，条例清晰，作为初学者的我从中学到了很多</span><span style="font-size: 14px;">linux</span><span style="font-size: 14px;">堆内存管理相关的知识。但是估计由于篇幅的限制，该文对很多难点一带而过，造成部分知识点理解上的困难。因此我决定以该文为蓝本，结合其他参考资料和自己的理解，写一篇足够详细、完整的</span><span style="font-size: 14px;">linux</span><span style="font-size: 14px;">堆管理介绍文章，希冀能够给其他初学者献上微末之力。所以就内容来源而言，本文主要由两部分组成：一部分是翻译的上面提及的文章；另一部分是笔者结合其他参考资料和自己的理解添加的补充说明。鉴于笔者知识能力上的不足，如有问题欢迎各位大牛斧正！</span></p>
<p><span style="font-size: 14px;">同样的，鉴于篇幅过长，我将文章分成了上下两部分，上部分主要介绍堆内存管理中的一些基本概念以及相互关系，同时也着重介绍了堆中</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">分配和释放策略中使用到的隐式链表技术。后半部分主要介绍</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">为了提高堆内存分配和释放的效率，引入的显示链表技术，即</span><span style="font-size: 14px;">binlist</span><span style="font-size: 14px;">的概念和核心原理。其中使用到的源码在：<a href="https://github.com/sploitfun/lsploits/tree/master/glibc" target="_blank">https://github.com/sploitfun/lsploits/tree/master/glibc</a></span></p>
<h2><span style="font-size: 18px;"><strong>1&nbsp;</strong></span><span style="font-size: 18px;"><strong>堆内存管理简介</strong></span></h2>
<p><span style="font-size: 14px;">当前针对各大平台主要有如下几种堆内存管理机制：</span></p>
<p><span style="font-size: 14px;">dlmalloc – General purpose allocator</span></p>
<p><strong>ptmalloc2 – glibc</strong></p>
<p><span style="font-size: 14px;">jemalloc – FreeBSD and Firefox</span></p>
<p><span style="font-size: 14px;">tcmalloc – Google</span></p>
<p><span style="font-size: 14px;">libumem – Solaris</span></p>
<p><span style="font-size: 14px;">本文主要学习介绍在</span><span style="font-size: 14px;">linux glibc</span><span style="font-size: 14px;">使用的</span><span style="font-size: 14px;">ptmalloc2</span><span style="font-size: 14px;">实现原理。</span></p>
<p><span style="font-size: 14px;">本来</span><span style="font-size: 14px;">linux</span><span style="font-size: 14px;">默认的是</span><span style="font-size: 14px;">dlmalloc</span><span style="font-size: 14px;">，但是由于其不支持多线程堆管理，所以后来被支持多线程的</span><span style="font-size: 14px;">prmalloc2</span><span style="font-size: 14px;">代替了。</span></p>
<p><span style="font-size: 14px;">当然在</span><span style="font-size: 14px;">linux</span><span style="font-size: 14px;">平台</span><span style="font-size: 14px;">*malloc</span><span style="font-size: 14px;">本质上都是通过系统调用</span><span style="font-size: 14px;">brk</span><span style="font-size: 14px;">或者</span><span style="font-size: 14px;">mmap</span><span style="font-size: 14px;">实现的。关于这部分内容，</span>一定要学习下面<span style="font-size: 14px;">这篇文章：</span></p>
<p><span style="font-size: 14px;"><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a></span></p>
<p><span style="font-size: 14px;">鉴于篇幅，本文就不加以详细说明了，只是为了方便后面对堆内存管理的理解，截取其中函数调用关系图：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4qg499890.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="276" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4qg499890.png" alt="" height="276" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">1-1&nbsp;</span><span style="font-size: 14px;">函数调用关系图</span></p>
<p style="text-align: center;"><span style="font-size: 14px;"><br /></span></p>
<p><span style="font-size: 14px;">系统内存分布图：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4qk4f6q40.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="524" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4qk4f6q40.png" alt="" height="524" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">1-2</span><span style="font-size: 14px;">系统内存分布图</span></p>
<p><span style="font-size: 14px;">&nbsp;</span></p>
<h2><span style="font-size: 18px;"><strong>2&nbsp;</strong></span><span style="font-size: 18px;"><strong>实验演示</strong></span></h2>
<p><span style="font-size: 14px;">试想有如下代码</span></p>
<table>
<colgroup>
<col width="NaN%"> </colgroup>
<thead>
<tr>
<th>  <span style="font-size: 10.5pt;">/* Per thread arena example. */</span>  <br /><span style="font-size: 10.5pt;">#include &lt;stdio.h&gt;</span>  <br /><span style="font-size: 10.5pt;">#include &lt;stdlib.h&gt;</span>  <br /><span style="font-size: 10.5pt;">#include &lt;pthread.h&gt;</span>  <br /><span style="font-size: 10.5pt;">#include &lt;unistd.h&gt;</span>  <br /><span style="font-size: 10.5pt;">#include &lt;sys/types.h&gt;</span>  &nbsp;  <br /><span style="font-size: 10.5pt;">void* threadFunc(void* arg) {<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&#8220;Before malloc in thread 1\n&#8221;);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getchar();<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; char*  addr = (char*) malloc(1000);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&#8220;After malloc and before free in thread 1\n&#8221;);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getchar();<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;free(addr);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&#8220;After free in thread 1\n&#8221;);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getchar();</span>  <span style="font-size: 10.5pt;">}</span>  &nbsp;  <br /><span style="font-size: 10.5pt;"><br />int main() {<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pthread_t t1;<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void*  s;<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int  ret;<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char*  addr;</p>
<p></span>&nbsp; &nbsp; &nbsp;<span style="font-size: 10.5pt;">&nbsp; &nbsp;printf(&#8220;Welcome to per thread arena  example::%d\n&#8221;,getpid());<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&#8220;Before malloc in main thread\n&#8221;);<br /></span>&nbsp;<span style="font-size: 10.5pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  getchar();<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; addr =  (char*) malloc(1000);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&#8220;After malloc and before free in main thread\n&#8221;);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getchar();<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;free(addr);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&#8220;After free in main thread\n&#8221;);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getchar();<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; ret =  pthread_create(&amp;t1, NULL, threadFunc, NULL);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(ret)<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; {<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&#8220;Thread creation  error\n&#8221;);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return -1;<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; }<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; ret =  pthread_join(t1, &amp;s);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(ret)<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; {<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&#8220;Thread join error\n&#8221;);<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return -1;<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; }<br /></span>  <span style="font-size: 10.5pt;">&nbsp; &nbsp; &nbsp; &nbsp; return  0;<br /></span>  <span style="font-size: 10.5pt;">}</span>  </th>
</tr>
</thead>
</table>
<p>&nbsp;<span style="font-size: 14px;">下面我们依次分析其各个阶段的堆内存分布状况。</span></p>
<p><span style="font-size: 14px;"><strong>1.&nbsp;</strong></span><span style="font-size: 14px;"><strong>Before malloc in main thread</strong></span><span style="font-size: 14px;">&nbsp;<strong>:</strong></span></p>
<p><span style="font-size: 14px;">在程序调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">之前程序进程中是没有</span><span style="font-size: 14px;">heap segment</span><span style="font-size: 14px;">的，并且在创建在创建线程前，也是没有线程堆栈的。</span></p>
<p><span style="font-size: 14px;"><strong>2.&nbsp;</strong></span><span style="font-size: 14px;"><strong>After malloc&nbsp;in main thread</strong></span><span style="font-size: 14px;">&nbsp;<strong>:</strong></span></p>
<p><span style="font-size: 14px;">在主线程中调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">之后，就会发现系统给程序分配了堆栈，且这个堆栈刚好在数据段之上：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/cvq2ln5sbii.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="195" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/cvq2ln5sbii.png" alt="" height="195" width="600"></p></noscript>
<p><span style="font-size: 14px;">这就说明它是通过</span><span style="font-size: 14px;">brk</span><span style="font-size: 14px;">系统调用实现的。并且，还可以看出虽然我们只申请了</span><span style="font-size: 14px;">1000</span><span style="font-size: 14px;">字节的数据，但是系统却分配了</span><span style="font-size: 14px;">132KB</span><span style="font-size: 14px;">大小的堆，这是为什么呢？原来这</span><span style="font-size: 14px;">132KB</span><span style="font-size: 14px;">的堆空间叫做</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">，此时因为是主线程分配的，所以叫做</span><span style="font-size: 14px;">main arena(</span><span style="font-size: 14px;">每个</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">中含有多个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">，这些</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">以链表的形式加以组织</span><span style="font-size: 14px;">)</span><span style="font-size: 14px;">。由于</span><span style="font-size: 14px;">132KB</span><span style="font-size: 14px;">比</span><span style="font-size: 14px;">1000</span><span style="font-size: 14px;">字节大很多，所以主线程后续再声请堆空间的话，就会先从这</span><span style="font-size: 14px;">132KB</span><span style="font-size: 14px;">的剩余部分中申请，直到用完或不够用的时候，再通过增加</span><span style="font-size: 14px;">program break location</span><span style="font-size: 14px;">的方式来增加</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">的大小。同理，当</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">中有过多空闲内存的时候，也会通过减小</span><span style="font-size: 14px;">program break location</span><span style="font-size: 14px;">的方式来缩小</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">的大小。</span></p>
<p><span style="font-size: 14px;"><strong>3.&nbsp;</strong></span><span style="font-size: 14px;"><strong>After free in main thread</strong></span><span style="font-size: 14px;">&nbsp;<strong>:</strong></span></p>
<p><span style="font-size: 14px;">在主线程调用</span><span style="font-size: 14px;">free</span><span style="font-size: 14px;">之后：从内存布局可以看出程序的堆空间并没有被释放掉，原来调用</span><span style="font-size: 14px;">free</span><span style="font-size: 14px;">函数释放已经分配了的空间并非直接</span><span style="font-size: 14px;">“</span><span style="font-size: 14px;">返还</span><span style="font-size: 14px;">”</span><span style="font-size: 14px;">给系统，而是由</span><span style="font-size: 14px;">glibc&nbsp;</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">库函数加以管理。它会将释放的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">添加到</span><span style="font-size: 14px;">main arenas</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">bin(</span><span style="font-size: 14px;">这是一种用于存储同类型</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">的双链表数据结构，后问会加以详细介绍</span><span style="font-size: 14px;">)</span><span style="font-size: 14px;">中。在这里，记录空闲空间的</span><span style="font-size: 14px;">freelist</span><span style="font-size: 14px;">数据结构称之为</span><span style="font-size: 14px;">bins</span><span style="font-size: 14px;">。之后当用户再次调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">申请堆空间的时候，</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">会先尝试从</span><span style="font-size: 14px;">bins</span><span style="font-size: 14px;">中找到一个满足要求的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">，如果没有才会向操作系统申请新的堆空间。如下图所示：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4qsnu2s70.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="224" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4qsnu2s70.png" alt="" height="224" width="600"></p></noscript>
<p><span style="font-size: 14px;">&nbsp;</span></p>
<p><span style="font-size: 14px;"><strong>4.&nbsp;</strong></span><span style="font-size: 14px;"><strong>Before malloc in thread1</strong></span><span style="font-size: 14px;">&nbsp;<strong>:</strong></span></p>
<p><span style="font-size: 14px;">在</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">之前：从输出结果可以看出</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">中并没有</span><span style="font-size: 14px;">heap segment</span><span style="font-size: 14px;">，但是此时</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">自己的栈空间已经分配完毕了：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4quu57860.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="276" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4quu57860.png" alt="" height="276" width="600"></p></noscript>
<p><span style="font-size: 14px;">&nbsp;</span></p>
<p><span style="font-size: 14px;"><strong>5.&nbsp;</strong></span><span style="font-size: 14px;"><strong>After malloc in thread1</strong></span><span style="font-size: 14px;">&nbsp;<strong>:</strong></span></p>
<p><span style="font-size: 14px;">在</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">之后：从输出结果可以看出</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">heap segment</span><span style="font-size: 14px;">已经分配完毕了，同时从这个区域的起始地址可以看出，它并不是通过</span><span style="font-size: 14px;">brk</span><span style="font-size: 14px;">分配的，而是通过</span><span style="font-size: 14px;">mmap</span><span style="font-size: 14px;">分配，因为它的区域为</span><span style="font-size: 14px;">b7500000-b7600000</span><span style="font-size: 14px;">共</span><span style="font-size: 14px;">1MB</span><span style="font-size: 14px;">，并不是同程序的</span><span style="font-size: 14px;">data segment</span><span style="font-size: 14px;">相邻。同时，我们还能看出在这</span><span style="font-size: 14px;">1MB</span><span style="font-size: 14px;">中，根据内存属性分为了</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">部分：</span><span style="font-size: 14px;">0xb7500000-0xb7520000</span><span style="font-size: 14px;">共</span><span style="font-size: 14px;">132KB</span><span style="font-size: 14px;">大小的空间是可读可写属性；后面的是不可读写属性。原来，这里只有可读写的</span><span style="font-size: 14px;">132KB</span><span style="font-size: 14px;">空间才是</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">的堆空间，即</span><span style="font-size: 14px;">thread1 arena</span><span style="font-size: 14px;">。</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4r10lm3u0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="188" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4r10lm3u0.png" alt="" height="188" width="600"></p></noscript>
<p></p>
<p><span style="font-size: 14px;">6.&nbsp;</span><span style="font-size: 14px;">在</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">调用</span><span style="font-size: 14px;">free</span><span style="font-size: 14px;">之后：同</span><span style="font-size: 14px;">main thread</span><span style="font-size: 14px;">。</span></p>
<h2><span style="font-size: 18px;"><strong>3 Arena</strong></span><span style="font-size: 18px;"><strong>介绍</strong></span></h2>
<h3><span style="font-size: 16px;"><strong>3.1 Arena</strong></span><span style="font-size: 16px;"><strong>数量限制</strong></span></h3>
<p><span style="font-size: 14px;">在第</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">章中我们提到</span><span style="font-size: 14px;">main thread</span><span style="font-size: 14px;">和</span><span style="font-size: 14px;">thread1</span><span style="font-size: 14px;">有自己独立的</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">，那么是不是无论有多少个线程，每个线程都有自己独立的</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">呢？答案是否定的。事实上，</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">的个数是跟系统中处理器核心个数相关的，如下表所示：</span></p>
<table>
<colgroup>
<col width="NaN%"></colgroup>
<thead>
<tr>
<th><span style="font-size: 14px;">For&nbsp;</span><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1754"><span style="font-size: 14px;">32 bit</span></a><span style="font-size: 14px;">&nbsp;systems:<br /></span><span style="font-size: 14px;">&nbsp; &nbsp; &nbsp;Number of arena = 2 * number of cores + 1.<br /></span><span style="font-size: 14px;">For&nbsp;</span><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1754"><span style="font-size: 14px;">64 bit</span></a><span style="font-size: 14px;">&nbsp;systems:<br /></span><span style="font-size: 14px;">&nbsp; &nbsp; &nbsp;Number of arena = 8 * number of cores + 1.</span></th>
</tr>
</thead>
</table>
<h3><span style="font-size: 16px;"><strong>3.2&nbsp;</strong></span><span style="font-size: 16px;"><strong>多</strong></span><span style="font-size: 16px;"><strong>Arena</strong></span><span style="font-size: 16px;"><strong>的管理</strong></span></h3>
<p><span style="font-size: 14px;">假设有如下情境：一台只含有一个处理器核心的</span><span style="font-size: 14px;">PC</span><span style="font-size: 14px;">机安装有</span><span style="font-size: 14px;">32</span><span style="font-size: 14px;">位操作系统，其上运行了一个多线程应用程序，共含有</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">个线程</span><span style="font-size: 14px;">——</span><span style="font-size: 14px;">主线程和三个用户线程。显然线程个数大于系统能维护的最大</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">个数（</span><span style="font-size: 14px;">2*</span><span style="font-size: 14px;">核心数</span><span style="font-size: 14px;">&nbsp;+ 1= 3</span><span style="font-size: 14px;">），那么此时</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">就需要确保这</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">个线程能够正确地共享这</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">个</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">，那么它是如何实现的呢？</span></p>
<p><span style="font-size: 14px;">当主线程首次调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">的时候，</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">会直接为它分配一个</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">，而不需要任何附加条件。</span></p>
<p><span style="font-size: 14px;">当用户线程</span><span style="font-size: 14px;">1</span><span style="font-size: 14px;">和用户线程</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">首次调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">的时候，</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">会分别为每个用户线程创建一个新的</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">。此时，各个线程与</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">是一一对应的。但是，当用户线程</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">的时候，就出现问题了。因为此时</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">能维护的</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">个数已经达到上限，无法再为线程</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">分配新的</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">了，那么就需要重复使用已经分配好的</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">个</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">中的一个</span><span style="font-size: 14px;">(main arena, arena 1</span><span style="font-size: 14px;">或者</span><span style="font-size: 14px;">arena 2)</span><span style="font-size: 14px;">。那么该选择哪个</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">进行重复利用呢？</span></p>
<p><span style="font-size: 14px;">1)</span><span style="font-size: 14px;">首先，</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">循环遍历所有可用的</span><span style="font-size: 14px;">arenas</span><span style="font-size: 14px;">，在遍历的过程中，它会尝试</span><span style="font-size: 14px;">lock</span><span style="font-size: 14px;">该</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">。如果成功</span><span style="font-size: 14px;">lock(</span><span style="font-size: 14px;">该</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">当前对应的线程并未使用堆内存则表示可</span><span style="font-size: 14px;">lock)</span><span style="font-size: 14px;">，比如将</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">成功</span><span style="font-size: 14px;">lock</span><span style="font-size: 14px;">住，那么就将</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">返回给用户，即表示该</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">被线程</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">共享使用。</span></p>
<p><span style="font-size: 14px;">2)</span><span style="font-size: 14px;">而如果没能找到可用的</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">，那么就将线程</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">操作阻塞，直到有可用的</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">为止。</span></p>
<p><span style="font-size: 14px;">3)</span><span style="font-size: 14px;">现在，如果线程</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">再次调用</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">的话，</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">就会先尝试使用最近访问的</span><span style="font-size: 14px;">arena(</span><span style="font-size: 14px;">此时为</span><span style="font-size: 14px;">main arena)</span><span style="font-size: 14px;">。如果此时</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">可用的话，就直接使用，否则就将线程</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">阻塞，直到</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">再次可用为止。</span></p>
<p><span style="font-size: 14px;">这样线程</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">与主线程就共享</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">了。至于其他更复杂的情况，以此类推。</span></p>
<h2><span style="font-size: 18px;"><strong>4&nbsp;</strong></span><span style="font-size: 18px;"><strong>堆管理介绍</strong></span></h2>
<h3><span style="font-size: 16px;"><strong>4.1&nbsp;</strong></span><span style="font-size: 16px;"><strong>整体介绍</strong></span></h3>
<p><span style="font-size: 14px;">在</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">中针对堆管理，主要涉及到以下</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">种数据结构：</span></p>
<p><span style="font-size: 14px;">1. heap_info:&nbsp;</span><span style="font-size: 14px;">即</span><span style="font-size: 14px;">Heap Header</span><span style="font-size: 14px;">，因为一个</span><strong>thread arena</strong><strong>（注意：不包含</strong><strong>main thread</strong><strong>）</strong><span style="font-size: 14px;">可以包含多个</span><span style="font-size: 14px;">heaps</span><span style="font-size: 14px;">，所以为了便于管理，就给每个</span><span style="font-size: 14px;">heap</span><span style="font-size: 14px;">分配一个</span><span style="font-size: 14px;">heap header</span><span style="font-size: 14px;">。那么在什么情况下一个</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">会包含多个</span><span style="font-size: 14px;">heaps</span><span style="font-size: 14px;">呢</span><span style="font-size: 14px;">?</span><span style="font-size: 14px;">在当前</span><span style="font-size: 14px;">heap</span><span style="font-size: 14px;">不够用的时候，</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">会通过系统调用</span><span style="font-size: 14px;">mmap</span><span style="font-size: 14px;">申请新的堆空间，新的堆空间会被添加到当前</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">中，便于管理。</span></p>
<table>
<colgroup>
<col width="NaN%"></colgroup>
<thead>
<tr>
<th><span style="font-size: 14px;">typedef struct _heap_info<br /></span><span style="font-size: 14px;">{<br /></span><span style="font-size: 14px;">&nbsp; mstate ar_ptr; /* Arena for this heap. */<br /></span><span style="font-size: 14px;">&nbsp; struct _heap_info *prev; /* Previous heap. */<br /></span><span style="font-size: 14px;">&nbsp; size_t size;&nbsp;&nbsp; /* Current size in bytes. */<br /></span><span style="font-size: 14px;">&nbsp; size_t mprotect_size; /* Size in bytes that has been mprotected<br /></span><span style="font-size: 14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PROT_READ|PROT_WRITE.&nbsp; */<br /></span><span style="font-size: 14px;">&nbsp; /* Make sure the following data is properly aligned, particularly<br /></span><span style="font-size: 14px;">&nbsp; &nbsp; &nbsp;that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of<br /></span><span style="font-size: 14px;">&nbsp; &nbsp; &nbsp;MALLOC_ALIGNMENT. */<br /></span><span style="font-size: 14px;">&nbsp; char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br /></span><span style="font-size: 14px;">} heap_info;</span></th>
</tr>
</thead>
</table>
<p><span style="font-size: 14px;">2. malloc_state:&nbsp;</span><span style="font-size: 14px;">即</span><span style="font-size: 14px;">Arena Header</span><span style="font-size: 14px;">，每个</span><span style="font-size: 14px;">thread</span><span style="font-size: 14px;">只含有一个</span><span style="font-size: 14px;">Arena Header</span><span style="font-size: 14px;">。</span><span style="font-size: 14px;">Arena Header</span><span style="font-size: 14px;">包含</span><span style="font-size: 14px;">bins</span><span style="font-size: 14px;">的信息、</span><span style="font-size: 14px;">top chunk</span><span style="font-size: 14px;">以及最后一个</span><span style="font-size: 14px;">remainder chunk</span><span style="font-size: 14px;">等</span><span style="font-size: 14px;">(</span><span style="font-size: 14px;">这些概念会在后文详细介绍</span><span style="font-size: 14px;">):</span></p>
<table>
<colgroup>
<col width="NaN%"></colgroup>
<thead>
<tr>
<th><span style="font-size: 14px;">struct malloc_state<br /></span><span style="font-size: 14px;">{<br /></span><span style="font-size: 14px;">&nbsp; /* Serialize access.&nbsp; */<br /></span><span style="font-size: 14px;">&nbsp; mutex_t mutex;<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Flags (formerly in max_fast).&nbsp; */<br /></span><span style="font-size: 14px;">&nbsp; int flags;<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Fastbins */<br /></span><span style="font-size: 14px;">&nbsp; mfastbinptr fastbinsY[NFASTBINS];<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Base of the topmost chunk &#8212; not otherwise kept in a bin */<br /></span><span style="font-size: 14px;">&nbsp; mchunkptr top;<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* The remainder from the most recent split of a small request */<br /></span><span style="font-size: 14px;">&nbsp; mchunkptr last_remainder;<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Normal bins packed as described above */<br /></span><span style="font-size: 14px;">&nbsp; mchunkptr bins[NBINS * 2 - 2];<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Bitmap of bins */<br /></span><span style="font-size: 14px;">&nbsp; unsigned int binmap[BINMAPSIZE];<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Linked list */<br /></span><span style="font-size: 14px;">&nbsp; struct malloc_state *next;<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Linked list for free arenas.&nbsp; */<br /></span><span style="font-size: 14px;">&nbsp; struct malloc_state *next_free;<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Memory allocated from the system in this arena.&nbsp; */<br /></span><span style="font-size: 14px;">&nbsp; INTERNAL_SIZE_T system_mem;<br /></span><span style="font-size: 14px;">&nbsp; INTERNAL_SIZE_T max_system_mem;<br /></span><span style="font-size: 14px;">};</span></th>
</tr>
</thead>
</table>
<p><span style="font-size: 14px;">&nbsp;3. malloc_chunk:&nbsp;</span><span style="font-size: 14px;">即</span><span style="font-size: 14px;">Chunk Header</span><span style="font-size: 14px;">，一个</span><span style="font-size: 14px;">heap</span><span style="font-size: 14px;">被分为多个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">，至于每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的大小，这是根据用户的请求决定的，也就是说用户调用</span><span style="font-size: 14px;">malloc(size)</span><span style="font-size: 14px;">传递的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">参数</span><span style="font-size: 14px;">“</span><span style="font-size: 14px;">就是</span><span style="font-size: 14px;">”chunk</span><span style="font-size: 14px;">的大小</span><span style="font-size: 14px;">(</span><span style="font-size: 14px;">这里给</span><span style="font-size: 14px;">“</span><span style="font-size: 14px;">就是</span><span style="font-size: 14px;">”</span><span style="font-size: 14px;">加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文</span><span style="font-size: 14px;">)</span><span style="font-size: 14px;">。每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">都由一个结构体</span><span style="font-size: 14px;">malloc_chunk</span><span style="font-size: 14px;">表示：</span></p>
<table>
<colgroup>
<col width="NaN%"></colgroup>
<thead>
<tr>
<th><span style="font-size: 14px;">struct malloc_chunk {<br /></span><span style="font-size: 14px;">&nbsp; /* #define INTERNAL_SIZE_T size_t */<br /></span><span style="font-size: 14px;">&nbsp; INTERNAL_SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_size;&nbsp; /* Size of previous chunk (if free).&nbsp; */<br /></span><span style="font-size: 14px;">&nbsp; INTERNAL_SIZE_T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;/* Size in bytes, including overhead. */<br /></span><span style="font-size: 14px;">&nbsp; struct malloc_chunk* fd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;</span><strong>double links &#8212; used only if free.&nbsp;</strong><strong>这两个指针只在</strong><strong>free chunk</strong><strong>中存在</strong><span style="font-size: 14px;">*/<br /></span><span style="font-size: 14px;">&nbsp; struct malloc_chunk* bk;<br /></span><span style="font-size: 14px;"><br />&nbsp;</span><span style="font-size: 14px;">&nbsp; /* Only used for large blocks: pointer to next larger size.&nbsp; */<br /></span><span style="font-size: 14px;">&nbsp; struct malloc_chunk* fd_nextsize; /* double links &#8212; used only if free. */<br /></span><span style="font-size: 14px;">&nbsp; struct malloc_chunk* bk_nextsize;<br /></span><span style="font-size: 14px;">};</span></th>
</tr>
</thead>
</table>
<p><span style="font-size: 14px;">可能有很多读者会疑惑：该结构体里面并没有一个类似于</span><span style="font-size: 14px;">data</span><span style="font-size: 14px;">的字段来表示用户申请到的堆内存空间啊？且该结构体明确含有</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">个</span><span style="font-size: 14px;">size_t</span><span style="font-size: 14px;">类型的成员，</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">个指针，这不就意味着</span><span style="font-size: 14px;">malloc_chunk</span><span style="font-size: 14px;">的大小是固定的了么？那它又如何能够根据用户的请求分配不同大小的内存呢？要想回答清楚这个问题，需要我们完全理解整个</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">的堆内存管理机制，同时，本文的主要目的之一就是希冀解释清楚这个概念，鉴于这部分内容较多，我将在后文的第</span><span style="font-size: 14px;">5</span><span style="font-size: 14px;">章加以详细介绍。</span></p>
<p><span style="font-size: 14px;"><i>NOTE:</i></span></p>
<p style="margin-left: 42pt;"><i><span style="font-size: 14px;">1.</span><span style="font-size: 14px;">&nbsp;</span><span style="font-size: 14px;">Main thread</span><span style="font-size: 14px;">不含有多个</span><span style="font-size: 14px;">heaps</span><span style="font-size: 14px;">所以也就不含有</span><span style="font-size: 14px;">heap_info</span><span style="font-size: 14px;">结构体。当需要更多堆空间的时候，就通过扩展</span><span style="font-size: 14px;">sbrk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">heap segment</span><span style="font-size: 14px;">来获取更多的空间，直到它碰到内存</span><span style="font-size: 14px;">mapping</span><span style="font-size: 14px;">区域为止。</span></i></p>
<p style="margin-left: 42pt;"><i><span style="font-size: 14px;">2.</span><span style="font-size: 14px;">&nbsp;</span><span style="font-size: 14px;">不同于</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">，</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">arena header</span><span style="font-size: 14px;">并不是</span><span style="font-size: 14px;">sbrk heap segment</span><span style="font-size: 14px;">的一部分，而是一个全局变量！因此它属于</span><span style="font-size: 14px;">libc.so</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">data segment</span><span style="font-size: 14px;">。</span></i></p>
<h3><span style="font-size: 16px;"><strong>4.2 heap segment</strong></span><span style="font-size: 16px;"><strong>与</strong></span><span style="font-size: 16px;"><strong>arena</strong></span><span style="font-size: 16px;"><strong>关系</strong></span></h3>
<p style="margin-left: 24pt;"><span style="font-size: 14px;">首先，通过内存分布图理清</span><span style="font-size: 14px;">malloc_state</span><span style="font-size: 14px;">与</span><span style="font-size: 14px;">heap_info</span><span style="font-size: 14px;">之间的组织关系。</span></p>
<p style="margin-left: 24pt;"><span style="font-size: 14px;">下图是只有一个</span><span style="font-size: 14px;">heap segment</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">和</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">的内存分布图：</span></p>
<p style="margin-left: 24pt; text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4skqanfb0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="414" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4skqanfb0.png" alt="" height="414" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">4-1&nbsp;</span><span style="font-size: 14px;">只含一个</span><span style="font-size: 14px;">heap segment</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">与</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">图</span></p>
<p><span style="font-size: 14px;">下图是一个</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">中含有多个</span><span style="font-size: 14px;">heap segments</span><span style="font-size: 14px;">的情况：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4snuicn70.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="522" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4snuicn70.png" alt="" height="522" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">4-1&nbsp;</span><span style="font-size: 14px;">一个</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">含有多个</span><span style="font-size: 14px;">heap segments</span><span style="font-size: 14px;">的内存分布图</span></p>
<p><span style="font-size: 14px;">从上图可以看出，</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">只含有一个</span><span style="font-size: 14px;">malloc_state(</span><span style="font-size: 14px;">即</span><span style="font-size: 14px;">arena header)</span><span style="font-size: 14px;">，却有两个</span><span style="font-size: 14px;">heap_info(</span><span style="font-size: 14px;">即</span><span style="font-size: 14px;">heap header)</span><span style="font-size: 14px;">。由于两个</span><span style="font-size: 14px;">heap segments</span><span style="font-size: 14px;">是通过</span><span style="font-size: 14px;">mmap</span><span style="font-size: 14px;">分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，</span><span style="font-size: 14px;">libc malloc</span><span style="font-size: 14px;">将第二个</span><span style="font-size: 14px;">heap_info</span><span style="font-size: 14px;">结构体的</span><span style="font-size: 14px;">prev</span><span style="font-size: 14px;">成员指向了第一个</span><span style="font-size: 14px;">heap_info</span><span style="font-size: 14px;">结构体的起始位置（即</span><span style="font-size: 14px;">ar_ptr</span><span style="font-size: 14px;">成员），而第一个</span><span style="font-size: 14px;">heap_info</span><span style="font-size: 14px;">结构体的</span><span style="font-size: 14px;">ar_ptr</span><span style="font-size: 14px;">成员指向了</span><span style="font-size: 14px;">malloc_state</span><span style="font-size: 14px;">，这样就构成了一个单链表，方便后续管理。</span></p>
<h2><span style="font-size: 18px;"><strong>5&nbsp;</strong></span><span style="font-size: 18px;"><strong>对</strong></span><span style="font-size: 18px;"><strong>chunk</strong></span><span style="font-size: 18px;"><strong>的理解</strong></span></h2>
<p><span style="font-size: 14px;">在</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">中将整个堆内存空间分成了连续的、大小不一的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">，即对于堆内存管理而言</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">就是最小操作单位。</span><span style="font-size: 14px;">Chunk</span><span style="font-size: 14px;">总共分为</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">类：</span><span style="font-size: 14px;">1)allocated chunk; 2)free chunk; 3)top chunk; 4)Last remainder chunk</span><span style="font-size: 14px;">。从本质上来说，所有类型的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">都是内存中一块连续的区域，只是通过该区域中</span><strong>特定位置的某些标识符</strong><span style="font-size: 14px;">加以区分。为了简便，我们先将这</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">类</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">简化为</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">类：</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">以及</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">，前者表示已经分配给用户使用的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">，后者表示未使用的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">。</span></p>
<p><span style="font-size: 14px;">众所周知，无论是何种堆内存管理器，其完成的核心目的都是能够高效地分配和回收内存块</span><span style="font-size: 14px;">(chunk)</span><span style="font-size: 14px;">。因此，它需要设计好相关算法以及相应的数据结构，而数据结构往往是根据算法的需要加以改变的。既然是算法，那么算法肯定有一个优化改进的过程，所以本文将根据堆内存管理器的演变历程，逐步介绍在</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">中</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">这种数据结构是如何设计出来的，以及这样设计的优缺点。</span></p>
<p><span style="font-size: 14px;">PS:</span><span style="font-size: 14px;">鉴于时间和精力有限，后文介绍的演变历程并没有加以严格考证，笔者只是按照一些参考书籍、自己的理解以及便于文章内容安排做出的</span><span style="font-size: 14px;">“</span><span style="font-size: 14px;">善意的捏造</span><span style="font-size: 14px;">”</span><span style="font-size: 14px;">，如有错误，欢迎大家斧正！</span></p>
<h3><span style="font-size: 16px;"><strong>5.1&nbsp;</strong></span><span style="font-size: 16px;"><strong>隐式链表技术</strong></span></h3>
<p><span style="font-size: 14px;">前文说过，任何堆内存管理器都是以</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的一部分嵌入到</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">内部，典型的设计如下所示：</span></p>
<p><span style="font-size: 14px;"><br /></span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4t08b8b90.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="205" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4t08b8b90.png" alt="" height="205" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-1&nbsp;</span><span style="font-size: 14px;">简单的</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">格式</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4t2iuejq0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt=""></p>
<noscript><img src="http://epo.alicdn.com/image/41u4t2iuejq0.png" alt=""></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-2&nbsp;</span><span style="font-size: 14px;">简单的</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">格式</span></p>
<p><span style="font-size: 14px;">堆内存中要求每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的大小必须为</span><span style="font-size: 14px;">8</span><span style="font-size: 14px;">的整数倍，因此</span><span style="font-size: 14px;">chunk size</span><span style="font-size: 14px;">的后</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">位是无效的，为了充分利用内存，堆管理器将这</span><span style="font-size: 14px;">3</span><span style="font-size: 14px;">个比特位用作</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的标志位，典型的就是将第</span><span style="font-size: 14px;">0</span><span style="font-size: 14px;">比特位用于标记该</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是否已经被分配。这样的设计很巧妙，因为我们只要获取了一个指向</span><span style="font-size: 14px;">chunk size</span><span style="font-size: 14px;">的指针，就能知道该</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的大小，即确定了此</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的边界，且利用</span><span style="font-size: 14px;">chunk size</span><span style="font-size: 14px;">的第</span><span style="font-size: 14px;">0</span><span style="font-size: 14px;">比特位还能知道该</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是否已经分配，这样就成功地将各个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">区分开来。注意在</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">中</span><span style="font-size: 14px;">padding</span><span style="font-size: 14px;">部分主要是用于地址对齐的</span><span style="font-size: 14px;">(</span><span style="font-size: 14px;">也可用于对付外部碎片</span><span style="font-size: 14px;">)</span><span style="font-size: 14px;">，即让整个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的大小为</span><span style="font-size: 14px;">8</span><span style="font-size: 14px;">的整数倍。</span></p>
<p><span style="font-size: 14px;">通过上面的设计，我们就能将整个堆内存组织成一个连续的已分配或未分配</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">序列</span><span style="font-size: 14px;">:</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4t70r0ja0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="600" width="385"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4t70r0ja0.png" alt="" height="600" width="385"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-3&nbsp;</span><span style="font-size: 14px;">简单的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">序列</span></p>
<p><span style="font-size: 14px;">上面的这种结构就叫做隐式链表。该链表隐式地由每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">，分析每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段，进而找到合适的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">。</span></p>
<p><span style="font-size: 14px;">细心的读者可能发现：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">的合并操作。我们知道，如果只对</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">合并技术。</span></p>
<p><span style="font-size: 14px;"><strong>1&nbsp;</strong></span><span style="font-size: 14px;"><strong>带边界标记的合并技术</strong></span></p>
<p><span style="font-size: 14px;">试想如下场景：假设我们要释放的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">为</span><span style="font-size: 14px;">P</span><span style="font-size: 14px;">，它紧邻的前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">为</span><span style="font-size: 14px;">FD</span><span style="font-size: 14px;">，紧邻的后一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">为</span><span style="font-size: 14px;">BK</span><span style="font-size: 14px;">，且</span><span style="font-size: 14px;">BK</span><span style="font-size: 14px;">与</span><span style="font-size: 14px;">FD</span><span style="font-size: 14px;">都为</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">。将</span><span style="font-size: 14px;">P</span><span style="font-size: 14px;">于</span><span style="font-size: 14px;">BK</span><span style="font-size: 14px;">合并在一起是很容易的，因为可以通过</span><span style="font-size: 14px;">P</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段轻松定位到</span><span style="font-size: 14px;">BK</span><span style="font-size: 14px;">的开始位置，进而获取</span><span style="font-size: 14px;">BK</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">等等，但是将</span><span style="font-size: 14px;">P</span><span style="font-size: 14px;">于</span><span style="font-size: 14px;">FD</span><span style="font-size: 14px;">合并却很难，我们必须从头遍历整个堆，找到</span><span style="font-size: 14px;">FD</span><span style="font-size: 14px;">，然后加以合并，这就意味着每次进行</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">释放操作消耗的时间与堆的大小成线性关系。为了解决这个问题，</span><span style="font-size: 14px;">Knuth</span><span style="font-size: 14px;">提出了一种聪明而通用的技术</span><span style="font-size: 14px;">——</span><span style="font-size: 14px;">边界标记。</span></p>
<p><span style="font-size: 14px;">Knuth</span><span style="font-size: 14px;">在每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的最后添加了一个脚部</span><span style="font-size: 14px;">(Footer)</span><span style="font-size: 14px;">，它就是该</span><span style="font-size: 14px;">chunk&nbsp;</span><span style="font-size: 14px;">头部</span><span style="font-size: 14px;">(header)</span><span style="font-size: 14px;">的一个副本，我们称之为边界标记：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4taa7tf40.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="246" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4taa7tf40.png" alt="" height="246" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-4&nbsp;</span><span style="font-size: 14px;">改进版的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">格式之</span><span style="font-size: 14px;">Knuth</span><span style="font-size: 14px;">边界标记</span></p>
<p><span style="font-size: 14px;">显然每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的脚部都在其相邻的下一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的头部的前</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的起始位置和分配状态，进而加以合并了。</span></p>
<p><span style="font-size: 14px;">但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话</span><span style="font-size: 14px;">(</span><span style="font-size: 14px;">比如</span><span style="font-size: 14px;">1</span><span style="font-size: 14px;">，</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">个字节</span><span style="font-size: 14px;">)</span><span style="font-size: 14px;">，就会造成很大的性能损耗。同时，考虑到只有在对</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">进行合并的时候才需要脚部，也就是说对于</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">而言它并不需要脚部，因此我们可以对这个脚部加以优化</span><span style="font-size: 14px;">——</span><span style="font-size: 14px;">将前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的已分配</span><span style="font-size: 14px;">/</span><span style="font-size: 14px;">空闲标记位存储在当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段的第</span><span style="font-size: 14px;">1</span><span style="font-size: 14px;">，或</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">比特位上，这样如果我们通过当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段知道了前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">为</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">，那么就可得出结论：当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">地址之前的</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">个字节为前一个</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">的脚部，我们可以通过该脚部获取前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的起始位置；如果当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段的标记位表明前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">的话，那么就可得出另一个结论：前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">没有脚部，即当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">地址之前的</span><span style="font-size: 14px;">4</span><span style="font-size: 14px;">个字节为前一个</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">payload</span><span style="font-size: 14px;">或</span><span style="font-size: 14px;">padding</span><span style="font-size: 14px;">的最后部分。新的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">格式图如下：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4tcui25d0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="245" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4tcui25d0.png" alt="" height="245" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-5&nbsp;</span><span style="font-size: 14px;">改进版的</span><span style="font-size: 14px;">Knuth</span><span style="font-size: 14px;">边界标记</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">格式</span></p>
<p><span style="font-size: 14px;">&nbsp;</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4ul339if0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="236" width="400"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4ul339if0.png" alt="" height="236" width="400"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-6&nbsp;</span><span style="font-size: 14px;">改进版的</span><span style="font-size: 14px;">Knuth</span><span style="font-size: 14px;">边界标记</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">格式</span></p>
<p><span style="font-size: 14px;"><strong>2&nbsp;</strong></span><span style="font-size: 14px;"><strong>再进化</strong></span><span style="font-size: 14px;"><strong>——</strong></span><span style="font-size: 14px;"><strong>支持多线程</strong></span></p>
<p><span style="font-size: 14px;">随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">格式已经难以满足需求，比如，我们需要标志位来标记当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是否属于非主线程即</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">，以及该</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">由</span><span style="font-size: 14px;">mmap</span><span style="font-size: 14px;">得来还是通过</span><span style="font-size: 14px;">brk</span><span style="font-size: 14px;">实现等等。但此时</span><span style="font-size: 14px;">chunk size</span><span style="font-size: 14px;">只剩下一个比特位未使用了，怎么办呢？这需要对</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">格式进行大手术！</span></p>
<p><span style="font-size: 14px;">首先思考：是否有必要同时保存当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">和<strong>前一个</strong></span><strong>chunk</strong><span style="font-size: 14px;">的已分配</span><span style="font-size: 14px;">/</span><span style="font-size: 14px;">空闲标记位？答案是否定的，因为我们只需要保存</span><span style="font-size: 14px;">前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的分配标志位就可以了，至于</span><strong>当前</strong><strong>chunk</strong><span style="font-size: 14px;">的分配标志位，可以通过查询</span><strong>下一个</strong><strong>chunk</strong><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段得到。那么</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">字段中剩下的两个比特位就可以用于满足多线程的标志需求了：</span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4tlflqvs0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="245" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4tlflqvs0.png" alt="" height="245" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-7&nbsp;</span><span style="font-size: 14px;">多线程版本</span><span style="font-size: 14px;">Knuth</span><span style="font-size: 14px;">边界标记</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">格式</span></p>
<p style="text-align: center;"><span style="font-size: 14px;">&nbsp;&nbsp;<img data-original="http://epo.alicdn.com/image/41u4u1fgal40.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="236" width="400">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<noscript><img src="http://epo.alicdn.com/image/41u4u1fgal40.png" alt="" height="236" width="400">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-8&nbsp;</span><span style="font-size: 14px;">多线程版本</span><span style="font-size: 14px;">Knuth</span><span style="font-size: 14px;">边界标记</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">格式</span></p>
<p><span style="font-size: 14px;">这里的</span><span style="font-size: 14px;">P,M,N</span><span style="font-size: 14px;">的含义如下：</span></p>
<table>
<colgroup>
<col width="NaN%"></colgroup>
<thead>
<tr>
<th><span style="font-size: 14px;">PREV_INUSE(P):&nbsp;</span><span style="font-size: 14px;">表示前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是否为</span><span style="font-size: 14px;">allocated</span><span style="font-size: 14px;">。<br /></span><span style="font-size: 14px;">IS_MMAPPED(M)</span><span style="font-size: 14px;">：表示当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是否是通过</span><span style="font-size: 14px;">mmap</span><span style="font-size: 14px;">系统调用产生的。<br /></span><span style="font-size: 14px;">NON_MAIN_ARENA(N)</span><span style="font-size: 14px;">：表示当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是否是</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">。</span></th>
</tr>
</thead>
</table>
<p><span style="font-size: 14px;"><br /></span></p>
<p><span style="font-size: 14px;">再进一步，发现没必要保存</span><span style="font-size: 14px;">chunk size</span><span style="font-size: 14px;">的副本，也就是说</span><span style="font-size: 14px;">Footer</span><span style="font-size: 14px;">的作用并不大，但是如果前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是</span><span style="font-size: 14px;">free</span><span style="font-size: 14px;">的话，在合并的时候我们又需要知道前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的大小，怎么办呢？将</span><span style="font-size: 14px;">Footer</span><span style="font-size: 14px;">从尾部移到首部，同时其不再保存当前</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">，而是前一个</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">不就行了。同样的，为了提高内存利用率，如果前一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">是</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">的话，这个</span><span style="font-size: 14px;">Footer</span><span style="font-size: 14px;">就作为</span><span style="font-size: 14px;">allocated chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">payload</span><span style="font-size: 14px;">或</span><span style="font-size: 14px;">padding</span><span style="font-size: 14px;">的一部分，结构图如下：</span></p>
<p><span style="font-size: 14px;"><br /></span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4u4r5kvt0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="249" width="600"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4u4r5kvt0.png" alt="" height="249" width="600"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-9&nbsp;</span><span style="font-size: 14px;">当前</span><span style="font-size: 14px;">glibc malloc allocated chunk</span><span style="font-size: 14px;">格式</span></p>
<p style="text-align: center;"><span style="font-size: 14px;"><br /></span></p>
<p style="text-align: center;"><img data-original="http://epo.alicdn.com/image/41u4u6t5tnk0.png" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" alt="" height="318" width="400"></p>
<noscript><img src="http://epo.alicdn.com/image/41u4u6t5tnk0.png" alt="" height="318" width="400"></p></noscript>
<p style="text-align: center;"><span style="font-size: 14px;">图</span><span style="font-size: 14px;">5-10&nbsp;</span><span style="font-size: 14px;">当前</span><span style="font-size: 14px;">glibc malloc free chunk</span><span style="font-size: 14px;">格式</span></p>
<p><span style="font-size: 14px;">至此，</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">堆内存管理器中使用的隐式链表技术就介绍完毕了。现在我们再回过头去看</span><span style="font-size: 14px;">malloc_chunk</span><span style="font-size: 14px;">结构体就很好理解了：该结构体通过每个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">prev_size</span><span style="font-size: 14px;">和</span><span style="font-size: 14px;">size</span><span style="font-size: 14px;">构成了隐式链表，而后续的</span><span style="font-size: 14px;">fd, bk</span><span style="font-size: 14px;">等指针并不是作用于隐式链表的，而是用于后文会介绍的用于加快内存分配和释放效率的显示链表</span><span style="font-size: 14px;">bin(</span><span style="font-size: 14px;">还记得</span><span style="font-size: 14px;">bin</span><span style="font-size: 14px;">么？用于记录同一类型</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">的链表</span><span style="font-size: 14px;">)</span><span style="font-size: 14px;">，并且这些指针跟</span><span style="font-size: 14px;">prev_size</span><span style="font-size: 14px;">一样只在</span><span style="font-size: 14px;">free chunk</span><span style="font-size: 14px;">中存在。关于显示链表</span><span style="font-size: 14px;">bin</span><span style="font-size: 14px;">的原理比较复杂，让我们带着疑惑，暂时略过这部分信息，等介绍完所有</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">之后再加以详细介绍。</span></p>
<h3><span style="font-size: 16px;"><strong>5.2 Top Chunk</strong></span></h3>
<p><span style="font-size: 14px;">当一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">处于一个</span><span style="font-size: 14px;">arena</span><span style="font-size: 14px;">的最顶部</span><span style="font-size: 14px;">(</span><span style="font-size: 14px;">即最高内存地址处</span><span style="font-size: 14px;">)</span><span style="font-size: 14px;">的时候，就称之为</span><span style="font-size: 14px;">top chunk</span><span style="font-size: 14px;">。该</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">并</span><span style="font-size: 14px;"><strong>不属于任何</strong></span><span style="font-size: 14px;"><strong>bin</strong></span><span style="font-size: 14px;">，而是在系统当前的所有</span><span style="font-size: 14px;">free chunk(</span><span style="font-size: 14px;">无论那种</span><span style="font-size: 14px;">bin)</span><span style="font-size: 14px;">都无法满足用户请求的内存大小的时候，将此</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">当做一个应急消防员，分配给用户使用。如果</span><span style="font-size: 14px;">top chunk</span><span style="font-size: 14px;">的大小比用户请求的大小要大的话，就将该</span><span style="font-size: 14px;">top chunk</span><span style="font-size: 14px;">分作两部分：</span><span style="font-size: 14px;">1</span><span style="font-size: 14px;">）用户请求的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">；</span><span style="font-size: 14px;">2</span><span style="font-size: 14px;">）剩余的部分成为新的</span><span style="font-size: 14px;">top chunk</span><span style="font-size: 14px;">。否则，就需要扩展</span><span style="font-size: 14px;">heap</span><span style="font-size: 14px;">或分配新的</span><span style="font-size: 14px;">heap</span><span style="font-size: 14px;">了</span><span style="font-size: 14px;">——</span><span style="font-size: 14px;">在</span><span style="font-size: 14px;">main arena</span><span style="font-size: 14px;">中通过</span><span style="font-size: 14px;">sbrk</span><span style="font-size: 14px;">扩展</span><span style="font-size: 14px;">heap</span><span style="font-size: 14px;">，而在</span><span style="font-size: 14px;">thread arena</span><span style="font-size: 14px;">中通过</span><span style="font-size: 14px;">mmap</span><span style="font-size: 14px;">分配新的</span><span style="font-size: 14px;">heap</span><span style="font-size: 14px;">。</span></p>
<h3><span style="font-size: 16px;"><strong>5.3 Last Remainder Chunk</strong></span></h3>
<p><span style="font-size: 14px;">要想理解此</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">就必须先理解</span><span style="font-size: 14px;">glibc malloc</span><span style="font-size: 14px;">中的</span><span style="font-size: 14px;">bin</span><span style="font-size: 14px;">机制。如果你已经看了第二部分文章，那么下面的原理就很好理解了，否则建议你先阅读第二部分文章。对于</span><span style="font-size: 14px;">Last remainder chunk</span><span style="font-size: 14px;">，我们主要有两个问题：</span><span style="font-size: 14px;">1)</span><span style="font-size: 14px;">它是怎么产生的；</span><span style="font-size: 14px;">2)</span><span style="font-size: 14px;">它的作用是什么？</span></p>
<p><span style="font-size: 14px;">先回答第一个问题。还记得第二部分文章中对</span><span style="font-size: 14px;">small bin</span><span style="font-size: 14px;">的</span><span style="font-size: 14px;">malloc</span><span style="font-size: 14px;">机制的介绍么？当用户请求的是一个</span><span style="font-size: 14px;">small chunk</span><span style="font-size: 14px;">，且该请求无法被</span><span style="font-size: 14px;">small bin</span><span style="font-size: 14px;">、</span><span style="font-size: 14px;">unsorted bin</span><span style="font-size: 14px;">满足的时候，就通过</span><span style="font-size: 14px;">binmaps</span><span style="font-size: 14px;">遍历</span><span style="font-size: 14px;">bin</span><span style="font-size: 14px;">查找最合适的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">，如果该</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">有剩余部分的话，就将该剩余部分变成一个新的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">加入到</span><span style="font-size: 14px;">unsorted bin</span><span style="font-size: 14px;">中，另外，</span>再将该新的chunk变成新的last remainder chunk<span style="font-size: 14px;">。</span></p>
<p><span style="font-size: 14px;">然后回答第二个问题。此类型的</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">用于提高连续</span><span style="font-size: 14px;">malloc(small chunk)</span><span style="font-size: 14px;">的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个</span><span style="font-size: 14px;">small chunk</span><span style="font-size: 14px;">，且该请求无法被</span><span style="font-size: 14px;">small bin</span><span style="font-size: 14px;">满足，那么就转而交由</span><span style="font-size: 14px;">unsorted bin</span><span style="font-size: 14px;">处理。同时，假设当前</span><span style="font-size: 14px;">unsorted bin</span><span style="font-size: 14px;">中只有一个</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">的话</span><span style="font-size: 14px;">——</span><span style="font-size: 14px;">就是</span><span style="font-size: 14px;">last remainder chunk</span><span style="font-size: 14px;">，那么就将该</span><span style="font-size: 14px;">chunk</span><span style="font-size: 14px;">分成两部分：前者分配给用户，剩下的部分放到</span><span style="font-size: 14px;">unsorted bin</span><span style="font-size: 14px;">中，并成为新的</span><span style="font-size: 14px;">last remainder chunk</span><span style="font-size: 14px;">。这样就保证了连续</span><span style="font-size: 14px;">malloc(small chunk)</span><span style="font-size: 14px;">中，各个</span><span style="font-size: 14px;">small chunk</span><span style="font-size: 14px;">在内存分布中是相邻的，即提高了内存分配的局部性。</span></p>
<p><strong><span style="font-size: 16px;">作者：走位@阿里聚安全，更多技术文章，请点击<a href="https://jaq.alibaba.com/community/index" target="_blank">阿里聚安全博客</a></span></strong></p>
        </div>
        <div class="article-oper">
        <!-- Baidu Button BEGIN -->
        <div class="share float-l"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
        <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","weixin","renren","tqq","douban","bdhome","hi","youdao","xg","fbook","twi","deli","linkedin","copy","print"],"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div>
        <!-- Baidu Button END -->
		<div class="statement">
        <div class="but-col"><span class='wpfp-span'><img src='http://www.freebuf.com/buf/plugins/wp-favorite-posts/img/heart.png' alt='Favorite' title='Favorite' class='wpfp-img' /><img src='http://www.freebuf.com/buf/plugins/wp-favorite-posts/img/loading.gif' alt='Loading' title='Loading' class='wpfp-hide wpfp-img' /><a class='wpfp-link' href='?wpfpaction=add&amp;postid=104144' title='收藏该文' rel='nofollow'>收藏该文</a></span></div>
		  </div>
		<span class="score float-r"></span>
        </div>        
        <div class=" panel panel-default author-info">
          <div class="author-detial">
		                <div class="user_photo"><img src="http://image.3001.net/2016/05/5999BF76BE2196E27242F9259C72D8ED.jpg" width="50" height="50" alt="阿里聚安全" class="avatar avatar-50 wp-user-avatar wp-user-avatar-50 photo" /></div>
            <p><span class="name"><a href="http://www.freebuf.com/author/%E9%98%BF%E9%87%8C%E8%81%9A%E5%AE%89%E5%85%A8" title="由 阿里聚安全 发布" rel="author">阿里聚安全</a></span>
			<span class="icon-f"><a href="http://www.freebuf.com/bufer" target="_blank"><img src="http://image.3001.net/images/index/f2.png" title="认证厂商"></a></span>
			<span><i class="colour-red">27</i>篇文章</span><span>等级：<i class="colour-green">5</i>级</span></p>
            <p>阿里巴巴移动安全官方</p>
                      </div>
                    <div class="but">
		  <a href="http://www.freebuf.com/author/阿里聚安全" class="btn btn-default btn-home">个人主页</a>
		  <a href="http://www.freebuf.com/user/pm?pmaction=newmessage&to=阿里聚安全" class="btn btn-default btn-letter">发私信</a>
		  </div>
		          </div>
                        		        <div class="article-pager">
          <ul>
            <li class="previous"><span>上一篇：</span><a href="http://www.freebuf.com/articles/terminal/104063.html" rel="prev">内网渗透防御：如何防御Hash注入攻击</a>			</li>
            <li class="next"><span>下一篇：</span>
			<a href="http://www.freebuf.com/articles/system/104221.html" rel="next">比特币敲诈者现身中文版Word</a>			</li>
          </ul>
        </div>
      </div>
      </div>
          <div class="comment-bright"><div class="main-tit04">
    <h3>这些评论亮了</h3></div>      <ul>      <li>
            <div class="user_photo">             <img src="http://image.3001.net/images/headimg/pic4.png">             </div>
            <div class="tit"><span class="name"> 马云 </span> 
						<span class="explain"></span>
			<span class="reply"><a onclick="return addComment.moveForm( 'comment-','', 'respond','104144' ) " href="?replytocom=#respond" class="comment-reply-link" rel="nofollow">回复</a></span></div>
            <div class="txt">
						小伙子写的不错</div>
            <div class="but"><span class="vote-count">)</span><span style="none" id="cos_support-2185364" class="vote-count">9</span><span class="vote-count">(</span><span class="vote">  <a class="ilike_icon" id="vote4-2185364" href="javascript:acv_vote(185364,1,2);">亮了</a></span></div>
          </li>
         </ul></div><div class="comment-list">
      <div class="main-tit02">
		<a rel="nofollow" class="btnbtn-default btn-comment" href="#respond">发表评论</a>
        <h3>已有 <span class="color_red">4</span> 条评论
      </div>
      <ul>
         <li class="comment even thread-even depth-1" id="li-comment-185364">
    <div id="comment-185364">
        <div class="photo">     <img src="http://image.3001.net/images/headimg/pic17.png">     </div>
    <div class="tit"> 
	    <span class="name"> 马云 </span>
        		<span class="explain">  </span>
		<span class="time">&nbsp;2016-05-13</span>
		<span class="time"> </span>
        <span class="useragent_output_custom"></span>
        <span class="useragent_output_custom"></span> 
		<span class="reply">
		        <!-- 正常情况 -->
           <a onclick="return addComment.moveForm( 'comment-185364','185364', 'respond','104144' ) " href="?replytocom=185364#respond" class="comment-reply-link" rel="nofollow">回复</a>
        	    </span>
		<span class="floor">1楼</span>
	</div>
	    <div class="txt">
	  <p class="useragent_output_custom"></p>
      <p>小伙子写的不错</p>
<div class="comment-tools">
<div class="vote" id="vote-185364"><span id="acv_stat_185364"></span><a class="ilike_icon"  id="vote4-185364" href="javascript:acv_vote(185364,1);">亮了</a>(<span id="cos_support-185364">9</span>)</div>
<div class="dropup"><a class="dropdown-toggle btn-report" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" style="display:none;"> 举报</a>
<ul class="dropdown-menu" style="display:none;bottom:auto;">
<li><a data-id="185364" class="click_report" href="javascript:;">广告等垃圾信息</a></li>
<li><a data-id="185364" class="click_report" href="javascript:;">不友善内容</a></li>
<li><a data-id="185364" class="click_report" href="javascript:;">违反法律法规的内容</a></li>
<li><a data-id="185364" class="click_report" href="javascript:;">不宜公开讨论的政治内容</a></li>
<li><a data-id="185364" class="click_report" href="javascript:;">其他</a></li>
</ul></div>
</div>
	</div></div>
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-185508">
    <div id="comment-185508">
        <div class="photo">     <img src="http://image.3001.net/images/headimg/pic5.png">     </div>
    <div class="tit"> 
	    <span class="name"> 翔龙小侠 </span>
        		<span class="explain">  </span>
		<span class="time">&nbsp;2016-05-14</span>
		<span class="time"> </span>
        <span class="useragent_output_custom"></span>
        <span class="useragent_output_custom"></span> 
		<span class="reply">
		        <!-- 正常情况 -->
           <a onclick="return addComment.moveForm( 'comment-185508','185508', 'respond','104144' ) " href="?replytocom=185508#respond" class="comment-reply-link" rel="nofollow">回复</a>
        	    </span>
		<span class="floor">2楼</span>
	</div>
	    <div class="txt">
	  <p class="useragent_output_custom"></p>
      <p>关于Arena这部分，为啥我的测试结果和你文中说的完全不一样呢。我这里是红帽系统2.6.35。</p>
<div class="comment-tools">
<div class="vote" id="vote-185508"><span id="acv_stat_185508"></span><a class="ilike_icon"  id="vote4-185508" href="javascript:acv_vote(185508,1);">亮了</a>(<span id="cos_support-185508">4</span>)</div>
<div class="dropup"><a class="dropdown-toggle btn-report" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" style="display:none;"> 举报</a>
<ul class="dropdown-menu" style="display:none;bottom:auto;">
<li><a data-id="185508" class="click_report" href="javascript:;">广告等垃圾信息</a></li>
<li><a data-id="185508" class="click_report" href="javascript:;">不友善内容</a></li>
<li><a data-id="185508" class="click_report" href="javascript:;">违反法律法规的内容</a></li>
<li><a data-id="185508" class="click_report" href="javascript:;">不宜公开讨论的政治内容</a></li>
<li><a data-id="185508" class="click_report" href="javascript:;">其他</a></li>
</ul></div>
</div>
	</div></div>
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-185579">
    <div id="comment-185579">
        <div class="photo">     <img src="http://image.3001.net/images/headimg/pic10.png">     </div>
    <div class="tit"> 
	    <span class="name"> PeanutKiller </span>
        		<span class="explain">  </span>
		<span class="time">&nbsp;2016-05-15</span>
		<span class="time"> </span>
        <span class="useragent_output_custom"></span>
        <span class="useragent_output_custom"></span> 
		<span class="reply">
		        <!-- 正常情况 -->
           <a onclick="return addComment.moveForm( 'comment-185579','185579', 'respond','104144' ) " href="?replytocom=185579#respond" class="comment-reply-link" rel="nofollow">回复</a>
        	    </span>
		<span class="floor">3楼</span>
	</div>
	    <div class="txt">
	  <p class="useragent_output_custom"></p>
      <p>文章总体不错, 但是有些相同概念前后用语不一致, 会让人误解.<br />
还有些地方对顺理成章就能理解的概念过多的修饰, 反而让人一头雾水.<br />
一些建议.<br />
感谢LZ分享这么详细的文章&#8230;</p>
<div class="comment-tools">
<div class="vote" id="vote-185579"><span id="acv_stat_185579"></span><a class="ilike_icon"  id="vote4-185579" href="javascript:acv_vote(185579,1);">亮了</a>(<span id="cos_support-185579">3</span>)</div>
<div class="dropup"><a class="dropdown-toggle btn-report" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" style="display:none;"> 举报</a>
<ul class="dropdown-menu" style="display:none;bottom:auto;">
<li><a data-id="185579" class="click_report" href="javascript:;">广告等垃圾信息</a></li>
<li><a data-id="185579" class="click_report" href="javascript:;">不友善内容</a></li>
<li><a data-id="185579" class="click_report" href="javascript:;">违反法律法规的内容</a></li>
<li><a data-id="185579" class="click_report" href="javascript:;">不宜公开讨论的政治内容</a></li>
<li><a data-id="185579" class="click_report" href="javascript:;">其他</a></li>
</ul></div>
</div>
	</div></div>
</li><!-- #comment-## -->
<li class="comment byuser comment-author-difcareer odd alt thread-odd thread-alt depth-1" id="li-comment-185720">
    <div id="comment-185720">
        <div class="photo"> <a href="http://www.freebuf.com/author/difcareer">
    <img src="http://www.freebuf.com/buf/plugins/wp-user-avatar/images/wp-user-avatar-96x96.png"></a>
     </div>
    <div class="tit"> 
	    <span class="name"> <a href="http://www.freebuf.com/author/difcareer" target="_blank">difcareer&nbsp;</a>  </span>
        		
		<span class="icon-f"> </span>
		<span class="rank">(3级)</span>
				<span class="explain"> 我在简书上发起了一个Android安全专题，分为很多个子专题... </span>
		<span class="time">&nbsp;2016-05-17</span>
		<span class="time"> </span>
        <span class="useragent_output_custom"></span>
        <span class="useragent_output_custom"></span> 
		<span class="reply">
		        <!-- 正常情况 -->
           <a onclick="return addComment.moveForm( 'comment-185720','185720', 'respond','104144' ) " href="?replytocom=185720#respond" class="comment-reply-link" rel="nofollow">回复</a>
        	    </span>
		<span class="floor">4楼</span>
	</div>
	    <div class="txt">
	  <p class="useragent_output_custom"></p>
      <p>赞，看懂了</p>
<div class="comment-tools">
<div class="vote" id="vote-185720"><span id="acv_stat_185720"></span><a class="ilike_icon"  id="vote4-185720" href="javascript:acv_vote(185720,1);">亮了</a>(<span id="cos_support-185720">4</span>)</div>
<div class="dropup"><a class="dropdown-toggle btn-report" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" style="display:none;"> 举报</a>
<ul class="dropdown-menu" style="display:none;bottom:auto;">
<li><a data-id="185720" class="click_report" href="javascript:;">广告等垃圾信息</a></li>
<li><a data-id="185720" class="click_report" href="javascript:;">不友善内容</a></li>
<li><a data-id="185720" class="click_report" href="javascript:;">违反法律法规的内容</a></li>
<li><a data-id="185720" class="click_report" href="javascript:;">不宜公开讨论的政治内容</a></li>
<li><a data-id="185720" class="click_report" href="javascript:;">其他</a></li>
</ul></div>
</div>
	</div></div>
</li><!-- #comment-## -->
      </ul>
      <div class="commentnav page01" style="padding-top:10px; text-align: center;">
               </div>
	  
<script src="http://www.freebuf.com/buf/themes/freebuf/js/ajaxfileupload.js" type="text/javascript"></script>
<div id="respond" class="comment-box">
<input type="file" id="uploadUnit" name="upfile" class="hidden" value="">
    <form action="http://www.freebuf.com/wp-comments-post.php" method="post" id="commentform">
        <div id="comment-author-info">
	    <div class="login-other">
		  <div class="login_button login_icon_sina" title="使用新浪微博登陆" onclick="login_button_click('sina')"></div>
          <div class="login_button login_icon_qq" title="使用腾讯QQ登陆" onclick="login_button_click('qq')"></div></div>
        <div class="login-input">
	    <p><label for="author">昵称</label>
		          <input type="text" name="author" id="author" value="" size="14" tabindex="1" aria-required='true' placeholder = "请输入昵称" required />
        </p><span>必须</span><span>您当前尚未登录。<a  class="simplemodal-login" href="http://www.freebuf.com/wp-login.php?redirect_to=http%3A%2F%2Ffreebuf.com%2Farticles%2Fsystem%2F104144.html" title="登陆">登陆？</a><a  href="http://www.freebuf.com/wp-login.php?action=register" target="_blank">注册</a></span></div>
		<div class="login-input">
		  <p><label for="email">邮箱</label><input type="text" name="email" id="email" value="" size="25" tabindex="2" aria-required='true' placeholder = "请输入邮箱地址" required /></p>
		<span>必须（保密）</span>
		</div>
    </div>

        <div id="test" class="post-area">
      <div class="holiday"></div>
	    <div class="comment-editor">
			<a id="comment-smiley" href="javascript:;">表情</a><a href="javascript:;" id="imageThumb">插图</a>
	    </div>
        <div id="smileys" >
           <a title="mrgreen" href="javascript:grin(':mrgreen:')"><img src="http://image.3001.net/images/index/smilies/icon_mrgreen.gif" /></a><a title="razz" href="javascript:grin(':razz:')"><img src="http://image.3001.net/images/index/smilies/icon_razz.gif" /></a><a title="sad" href="javascript:grin(':sad:')"><img src="http://image.3001.net/images/index/smilies/icon_sad.gif" /></a><a title="smile" href="javascript:grin(':smile:')"><img src="http://image.3001.net/images/index/smilies/icon_smile.gif" /></a><a title="oops" href="javascript:grin(':oops:')"><img src="http://image.3001.net/images/index/smilies/icon_redface.gif" /></a><a title="grin" href="javascript:grin(':grin:')"><img src="http://image.3001.net/images/index/smilies/icon_biggrin.gif" /></a><a title="eek" href="javascript:grin(':eek:')"><img src="http://image.3001.net/images/index/smilies/icon_surprised.gif" /></a><a title="???" href="javascript:grin(':???:')"><img src="http://image.3001.net/images/index/smilies/icon_confused.gif" /></a><a title="cool" href="javascript:grin(':cool:')"><img src="http://image.3001.net/images/index/smilies/icon_cool.gif" /></a><a title="lol" href="javascript:grin(':lol:')"><img src="http://image.3001.net/images/index/smilies/icon_lol.gif" /></a><a title="mad" href="javascript:grin(':mad:')"><img src="http://image.3001.net/images/index/smilies/icon_mad.gif" /></a><a title="twisted" href="javascript:grin(':twisted:')"><img src="http://image.3001.net/images/index/smilies/icon_twisted.gif" /></a><a title="roll" href="javascript:grin(':roll:')"><img src="http://image.3001.net/images/index/smilies/icon_rolleyes.gif" /></a><a title="wink" href="javascript:grin(':wink:')"><img src="http://image.3001.net/images/index/smilies/icon_wink.gif" /></a><a title="idea" href="javascript:grin(':idea:')"><img src="http://image.3001.net/images/index/smilies/icon_idea.gif" /></a><a title="arrow" href="javascript:grin(':arrow:')"><img src="http://image.3001.net/images/index/smilies/icon_arrow.gif" /></a><a title="neutral" href="javascript:grin(':neutral:')"><img src="http://image.3001.net/images/index/smilies/icon_neutral.gif" /></a><a title="cry" href="javascript:grin(':cry:')"><img src="http://image.3001.net/images/index/smilies/icon_cry.gif" /></a><a title="?" href="javascript:grin(':?:')"><img src="http://image.3001.net/images/index/smilies/icon_question.gif" /></a><a title="evil" href="javascript:grin(':evil:')"><img src="http://image.3001.net/images/index/smilies/icon_evil.gif" /></a><a title="shock" href="javascript:grin(':shock:')"><img src="http://image.3001.net/images/index/smilies/icon_eek.gif" /></a><a title="!" href="javascript:grin(':!:')"><img src="http://image.3001.net/images/index/smilies/icon_exclaim.gif" /></a>        </div>
         <textarea name="comment" id="comment" cols="100%" rows="7" tabindex="4" style="overflow-x:hidden; overflow-y:hidden; border:0; width:100%;" onkeydown="if(event.ctrlKey&amp;&amp;event.keyCode==13){document.getElementById('submit').click();return false};"></textarea>
    </div>
      <div class="subcon but">
      <input class="btn btn-success" type="submit" name="submit" id="submit" tabindex="5" value="提交评论(Ctrl+Enter)" />
      <a rel="nofollow" class="btn btn-default" id="cancel-comment-reply-link" href="javascript:;">取消</a>
      <div class="checkbox"><input type='hidden' name='comment_post_ID' value='104144' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
<label for="comment_mail_notify" class="comment_mail"><input type="checkbox" name="comment_mail_notify" id="comment_mail_notify" value="comment_mail_notify" checked="checked"/>有人回复时邮件通知我</label></div>
      </div>
    <input name="Token" id="Token" type="hidden" value="x35l62" />
  </form>
  </div>
</div>	  
<div class="commentshow">
<div class="comments-loading">Loading...</div>
</div>
<script language="javascript">
jQuery(document).ready(function($){ //Begin jQuery
    $('.reply').click(function() {
    var atid = '"#' + $(this).parent().attr("id") + '"';
    var atname = $(this).parent().find('span:first').text();
    $("#comment").val("@" + atname + " ").focus();
});
    $('.cancel-comment-reply a').click(function() { //点击取消回复评论清空评论框的内容
    $("#comment").val('');
});
}) 

jQuery(document).ready(function($) {
    $body = (window.opera) ? (document.compatMode == "CSS1Compat" ? $('html') : $('body')) : $('html,body');//commentnav ajax
    $(document).on('click', '.commentnav a', function(e) {
        e.preventDefault();
        $.ajax({
            type: "GET",
            url: $(this).attr('href'),
            beforeSend: function() {
                $('.commentnav').remove();
                $('.comment-list').remove();
                $('.comments-loading').slideDown();
            },
            dataType: "html",
            success: function(out) {
                result = $(out).find('.comment-list');
                nextlink = $(out).find('.commentnav');
                $('.comments-loading').slideUp(550);
                $('.comments-loading').after(result.fadeIn(800));
                $(".comment-list img").each(function(){
                  var url = $(this).attr("data-original");
                  $(this).attr("src",url);
                })
            }
        });
    });    
});
</script>    </div>
        <div class="col-md-3 visible-md-block visible-lg-block">
      <div class="panel panel-default">
        <div class="author-wrap">
          <div class="author-header"><img src="http://image.3001.net/2016/05/5999BF76BE2196E27242F9259C72D8ED.jpg" width="100" height="100" alt="阿里聚安全" class="avatar avatar-100 wp-user-avatar wp-user-avatar-100 photo" /></div>
          <p class="name"><a href="http://www.freebuf.com/author/%E9%98%BF%E9%87%8C%E8%81%9A%E5%AE%89%E5%85%A8" title="由 阿里聚安全 发布" rel="author">阿里聚安全</a><span><a href="http://www.freebuf.com/bufer" target="_blank"><img src="http://image.3001.net/images/index/f2.png" title="认证厂商"></a></span></p>
          <p class="signature">阿里巴巴移动安全官方</p>
          <p class="art-com"><span class="aut-article"><a href="/author/阿里聚安全" target="_blank">27篇文章</a></span><span class="aut-comment"><a href="/author/阿里聚安全?comment=1" target="_blank">4条评论</a></span></p>
        </div>
      </div>
	  <script type="text/javascript">
	          var dispatch = function() {
              q = document.getElementById("q");
              if (q.value != "") {
                  window.open('http://www.freebuf.com/?s=' + q.value, "_blank");
                     return false;
                   } else {
                       return false;
                       }
             }
	  </script>
      <div class="form-group has-active search-col search-in">
        <form id="hpsform-new" class="navbar-search navbar-form" onsubmit="return dispatch()">
          <div class="form-group">
            <input id="q" class="input form-control" type="text" placeholder="关键字查找" autocomplete="off" title="关键字查找" name="q">
            <button class="submit" onclick="INTEL_TYPE_AHEAD.onSubmitHps(' 关键字查找', '/content/www/cn/zh', 'zh_CN')" value="Search" type="submit"></button>
          </div>
        </form>
      </div>
      <div class="ad-right" style="margin-bottom:24px;">
        <a href="http://click.aliyun.com/m/6683/" target="_blank"><img src="http://image.3001.net/images/20161012/14762626001909.jpg" width="263"></a>
      </div>
   
      <div class="panel panel-default">
        <div class="read visible-md-block visible-lg-block">
          <div class="main-tit02">
            <h3>相关阅读</h3>
          </div>		
          <ul>
  <li><a href="http://www.freebuf.com/news/88660.html" target="_blank">浅析Linux堆溢出之fastbin</a></li>
  
  <li><a href="http://www.freebuf.com/vuls/92465.html" target="_blank">Linux内核group_info UAF漏洞利用（CVE-2014-2851）</a></li>
  
  <li><a href="http://www.freebuf.com/articles/terminal/107276.html" target="_blank">ARM栈溢出攻击实践：从虚拟环境搭建到ROP利用</a></li>
  
  <li><a href="http://www.freebuf.com/articles/wireless/108830.html" target="_blank">揭秘：攻击者如何在Kali Linux中搭建钓鱼热点</a></li>
  
  <li><a href="http://www.freebuf.com/news/88396.html" target="_blank">Rekoobe：一款针对Linux的恶意软件</a></li>
  </ul>        </div>
      </div>
      <!--<div class="ad-wrap"><a href="http://www.ijiami.cn/?freebuf.com" target="_blank"><img width="100%" src="http://image.3001.net/images/20141201/14174039186901.jpg"></a></div>-->
      <div class="panel panel-default rec-spe">
        <div class="main-tit03 colour-blue">
          <h3>特别推荐</h3>
        </div>
         
      </div>
	  <div id="mar-right">
      <!--<div class="read visible-lg-block">
        <div class="main-tit04">
          <h3>商城新品</h3>
        </div>
        <div id="slider" class="nivoSlider">  </div>
      </div>-->
      <div class="panel panel-default code"> <img src="http://image.3001.net/images/new/code.jpg" width="192" height="192">
        <p>关注我们  分享每日精选文章</p>
      </div>
	  </div>
    </div>
  </div>
  <div class="row marvellous visible-lg-block">
    <h3>不容错过</h3>
    <ul>
      <li><a href="http://www.freebuf.com/news/topnews/112447.html" rel="bookmark" title="NSA（美国国安局）泄漏文件深度分析（PART 1）">NSA（美国国安局）泄漏文件深度分析（PART 1）</a>
        <p>		  <span class="name"><a href="http://www.freebuf.com/author/tom_vodu" title="由 tom_vodu 发布" rel="author">tom_vodu</a></span>
		  		<span class="time">2016-08-21</span></p>
      </li>
      <li><a href="http://www.freebuf.com/jobs/115236.html" rel="bookmark" title="「知乎」招聘安全人才">「知乎」招聘安全人才</a>
        <p>		  <span class="name"><a href="http://www.freebuf.com/author/%e7%9f%a5%e4%b9%8e%e5%ae%89%e5%85%a8" title="由 知乎安全 发布" rel="author">知乎安全</a></span>
		  		<span class="time">2016-09-26</span></p>
      </li>
      <li><a href="http://www.freebuf.com/fevents/38175.html" rel="bookmark" title="漏洞盒子项目上新：BTCC码交易中心网站安全测试">漏洞盒子项目上新：BTCC码交易中心网站安全测试</a>
        <p>		  <span class="name"><a href="http://www.freebuf.com/author/%e6%bc%8f%e6%b4%9e%e7%9b%92%e5%ad%90" title="由 漏洞盒子 发布" rel="author">漏洞盒子</a></span>
		  		<span class="time">2014-07-12</span></p>
      </li>
      <li><a href="http://www.freebuf.com/news/94668.html" rel="bookmark" title="走近YouTuBe上最受欢迎的黑客">走近YouTuBe上最受欢迎的黑客</a>
        <p>		  <span class="name"><a href="http://www.freebuf.com/author/0xroot" title="由 0xroot 发布" rel="author">0xroot</a></span>
		  		<span class="time">2016-02-01</span></p>
      </li>
    </ul>
  </div>
</div>
<script type="text/javascript">
  $(window).load(function() {
    $('#slider').nivoSlider();
  });
  $('#contenttxt img').removeAttr('height');
  $('#contenttxt img').wrap(function(){
    if(!$(this).parent().attr('href')){
      var imgurl = $(this).attr('data-original');
      if(imgurl.substr(-6)=='!small'){
        imgurl = imgurl.substring(0,imgurl.length-6);
      }
      return '<a href="' + imgurl + '" class="highslide-image" onclick="return hs.expand(this);" target="_blank"></a>';
    }
  })
</script>
<script src="http://www.freebuf.com/buf/themes/freebuf/js/comments-ajax.js" type="text/javascript"></script>
<script type="text/javascript" src="http://static.3001.net/js/focus/jquery.nivo.slider.pack.js"></script>
<!----------footer---------->
<div class="footer">
  <div class="container">
    <div class="footer-list col-sm-2 col-md-2">
      <h3>FREEBUF</h3>
      <ul>
        <li><a href="http://www.freebuf.com/dis">免责声明</a></li>
        <li><a href="http://www.freebuf.com/news/others/864.html">关于我们</a></li>
        <li><a href="http://www.freebuf.com/jobs/40386.html">加入我们</a></li>
        <li><a href="http://www.freebuf.com/donate">捐助我们</a></li>
      </ul>
    </div>
    <div class="footer-list col-sm-2 col-md-2">
      <h3>广告及服务</h3>
      <ul>
        <li><a target="_blank" href="mailto:root@freebuf.com">寻求报道</a></li>
        <li><a href="http://www.freebuf.com/advertise">广告合作</a></li>
        <li><a target="_blank" href="mailto:help@freebuf.com">联系我们</a></li>
        <li><a href="http://www.freebuf.com/friends">友情链接</a></li>
      </ul>
    </div>
    <div class="footer-list col-sm-2 col-md-2">
      <h3>关注我们</h3>
      <ul>
        <li><div class="weixin-pannel weixin"><a class="qr" href="javascript:viod(0);"><span class="g-icon-qr1">官方微信</span><i></i></a></div></li>
        <li><a rel="nofollow" target="_blank" href="http://weibo.com/freebuf">新浪微博</a></li>
        <li><a rel="nofollow" target="_blank" href="http://t.qq.com/freebuf">腾讯微博</a></li>
        <li><a rel="nofollow" target="_blank" href="http://twitter.com/freebuf">Twitter</a></li>
      </ul>
    </div>
    <div class="footer-list col-sm-2 col-md-2">
      <h3>赞助商</h3>
      <ul>
        <li style="padding:6px 0 10px;"><a rel="nofollow" target="_blank" href="http://www.aliyun.com/?freebuf"><img src="http://image.3001.net/images/ad/ali.png"></a></li>
        <li><a rel="nofollow" target="_blank" href="http://www.upyun.com/?freebuf"><img src="http://image.3001.net/images/ad/upyun.png"></a></li>
        <li style="padding:6px 0 10px;"><a rel="nofollow" target="_blank" href="https://www.trustasia.com/?freebuf"><img src="http://image.3001.net/images/ad/ad-yzcx.png"></a></li>
      </ul>
    </div>
    <div class="footer-list col-sm-2 col-md-2">
      <ul>
      </ul>
    </div>
    <div class="footer-logo col-sm-2 col-md-2 pull-right"><img src="http://image.3001.net/images/index/freebufrobot_shendanjie.png" ></div>
  </div>
  <div class="copyright"><div class="container"><p>Copyright &copy; 2013 WWW.FREEBUF.COM All Rights Reserved <a rel="nofollow" target="_blank" href="http://www.miitbeian.gov.cn">沪ICP备13033796号</a></p><span><a rel="nofollow" target="_blank" href="http://click.aliyun.com/m/1336/?freebuf"><img src="http://image.3001.net/images/new/icon-aly.png"></a></span></div></div>
</div>
<div class="bottom_tools"><a id="scrollUp" href="javascript:;" title="飞回顶部"></a></div>
<!----------footer end----------> 
<script src="http://static.3001.net/js/new/backtop.js"></script>
<script type="text/javascript">
jQuery(function(){	
	jQuery('.tabPanes ul li').click(function(){
		jQuery(this).addClass('hit').siblings().removeClass('hit');
		jQuery('.panesl>div:eq('+jQuery(this).index()+')').show().siblings().hide();	
	})
	jQuery('.vulbox-nav').click(function(e) { 
        e.stopPropagation(); 
    });  
})
</script>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fcc53db168808048541c6735ce30421f5' type='text/javascript'%3E%3C/script%3E"));
</script>
<img alt='css.php' src="http://www.freebuf.com/buf/plugins/cc/css.php?k=3cb185a485c81b23211eb80b75a406fd&amp;o=i&amp;t=2072982591" width='1' height='1' /><script type="text/javascript">
jQuery(function() {
    jQuery(".simditor pre").each(function(i, block){
        hljs.highlightBlock(block);    
    });
    hljs.initHighlightingOnLoad();
});
</script>
<script>
/* <![CDATA[ */
var rcGlobal = {
	serverUrl		:'http://www.freebuf.com',
	infoTemp		:'%REVIEWER% on %POST%',
	loadingText		:'Loading',
	noCommentsText	:'No comments',
	newestText		:'&laquo; 最新',
	newerText		:'&laquo; 新一点',
	olderText		:'旧一点 &raquo;',
	showContent		:'1',
	external		:'1',
	avatarSize		:'32',
	avatarPosition	:'left',
	anonymous		:'Anonymous'
};
/* ]]> */
</script>
<script type='text/javascript' src='http://static.3001.net/js/recentcomments/wp-recentcomments-jquery.js?ver=2.2.3'></script>
</body>
</html>
